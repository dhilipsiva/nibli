diff --git a/orchestrator/src/bindings.rs b/orchestrator/src/bindings.rs
index bf813e9..8edaf66 100644
--- a/orchestrator/src/bindings.rs
+++ b/orchestrator/src/bindings.rs
@@ -304,6 +304,8 @@ pub mod lojban {
                 Lo,
                 Le,
                 La,
+                RoLo,
+                RoLe,
             }
             impl ::core::fmt::Debug for Gadri {
                 fn fmt(
@@ -314,6 +316,8 @@ pub mod lojban {
                         Gadri::Lo => f.debug_tuple("Gadri::Lo").finish(),
                         Gadri::Le => f.debug_tuple("Gadri::Le").finish(),
                         Gadri::La => f.debug_tuple("Gadri::La").finish(),
+                        Gadri::RoLo => f.debug_tuple("Gadri::RoLo").finish(),
+                        Gadri::RoLe => f.debug_tuple("Gadri::RoLe").finish(),
                     }
                 }
             }
@@ -327,6 +331,8 @@ pub mod lojban {
                         0 => Gadri::Lo,
                         1 => Gadri::Le,
                         2 => Gadri::La,
+                        3 => Gadri::RoLo,
+                        4 => Gadri::RoLe,
                         _ => panic!("invalid enum discriminant"),
                     }
                 }
@@ -2290,42 +2296,42 @@ pub(crate) use __export_engine_pipeline_impl as export;
 )]
 #[doc(hidden)]
 #[allow(clippy::octal_escapes)]
-pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1498] = *b"\
-\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xd4\x0a\x01A\x02\x01\
+pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1510] = *b"\
+\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xe0\x0a\x01A\x02\x01\
 A\x13\x01B0\x01y\x04\0\x09selbri-id\x03\0\0\x01y\x04\0\x08sumti-id\x03\0\x02\x01\
 m\x05\x02fa\x02fe\x02fi\x02fo\x02fu\x04\0\x09place-tag\x03\0\x04\x01m\x04\x02se\x02\
 te\x02ve\x02xe\x04\0\x0aconversion\x03\0\x06\x01m\x04\x02je\x02ja\x02jo\x02ju\x04\
-\0\x0aconnective\x03\0\x08\x01m\x03\x02lo\x02le\x02la\x04\0\x05gadri\x03\0\x0a\x01\
-m\x02\x03poi\x03noi\x04\0\x0frel-clause-kind\x03\0\x0c\x01r\x02\x04kind\x0d\x0db\
-ody-sentencey\x04\0\x0arel-clause\x03\0\x0e\x01o\x02\x0b\x01\x01o\x02\x05\x03\x01\
-o\x02\x03\x0f\x01q\x07\x09pro-sumti\x01s\0\x0bdescription\x01\x10\0\x04name\x01s\
-\0\x0equoted-literal\x01s\0\x0bunspecified\0\0\x06tagged\x01\x11\0\x0arestricted\
-\x01\x12\0\x04\0\x05sumti\x03\0\x13\x01ps\x01o\x02\x01\x01\x01o\x02\x07\x01\x01p\
-\x03\x01o\x02\x01\x18\x01o\x03\x01\x09\x01\x01q\x08\x04root\x01s\0\x08compound\x01\
-\x15\0\x05tanru\x01\x16\0\x09converted\x01\x17\0\x07negated\x01\x01\0\x07grouped\
-\x01\x01\0\x09with-args\x01\x19\0\x09connected\x01\x1a\0\x04\0\x06selbri\x03\0\x1b\
-\x01r\x04\x08relation\x01\x0ahead-terms\x18\x0atail-terms\x18\x07negated\x7f\x04\
-\0\x05bridi\x03\0\x1d\x01p\x1c\x01p\x14\x01p\x1e\x01r\x03\x07selbris\x1f\x06sumt\
-is\x20\x09sentences!\x04\0\x0aast-buffer\x03\0\"\x01q\x04\x08variable\x01s\0\x08\
-constant\x01s\0\x0bdescription\x01s\0\x0bunspecified\0\0\x04\0\x0clogical-term\x03\
-\0$\x01p%\x01o\x02s&\x01o\x02yy\x01o\x02sy\x01q\x06\x09predicate\x01'\0\x08and-n\
-ode\x01(\0\x07or-node\x01(\0\x08not-node\x01y\0\x0bexists-node\x01)\0\x0cfor-all\
--node\x01)\0\x04\0\x0alogic-node\x03\0*\x01p+\x01py\x01r\x02\x05nodes,\x05roots-\
-\x04\0\x0clogic-buffer\x03\0.\x03\0\x1blojban:nesy/ast-types@0.1.0\x05\0\x02\x03\
-\0\0\x0aast-buffer\x01B\x05\x02\x03\x02\x01\x01\x04\0\x0aast-buffer\x03\0\0\x01j\
-\x01\x01\x01s\x01@\x01\x05inputs\0\x02\x04\0\x0aparse-text\x01\x03\x03\0\x18lojb\
-an:nesy/parser@0.1.0\x05\x02\x02\x03\0\0\x0clogic-buffer\x01B\x07\x02\x03\x02\x01\
-\x01\x04\0\x0aast-buffer\x03\0\0\x02\x03\x02\x01\x03\x04\0\x0clogic-buffer\x03\0\
-\x02\x01j\x01\x03\x01s\x01@\x01\x03ast\x01\0\x04\x04\0\x0ecompile-buffer\x01\x05\
-\x03\0\x1blojban:nesy/semantics@0.1.0\x05\x04\x01B\x08\x02\x03\x02\x01\x03\x04\0\
-\x0clogic-buffer\x03\0\0\x01j\0\x01s\x01@\x01\x05logic\x01\0\x02\x04\0\x0bassert\
--fact\x01\x03\x01j\x01\x7f\x01s\x01@\x01\x05logic\x01\0\x04\x04\0\x10query-entai\
-lment\x01\x05\x03\0\x1blojban:nesy/reasoning@0.1.0\x05\x05\x01j\x01y\x01s\x01@\x01\
-\x05inputs\0\x06\x04\0\x0bassert-text\x01\x07\x01j\x01\x7f\x01s\x01@\x01\x05inpu\
-ts\0\x08\x04\0\x0aquery-text\x01\x09\x01j\x01s\x01s\x01@\x01\x05inputs\0\x0a\x04\
-\0\x0dcompile-debug\x01\x0b\x04\0!lojban:nesy/engine-pipeline@0.1.0\x04\0\x0b\x15\
-\x01\0\x0fengine-pipeline\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit\
--component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
+\0\x0aconnective\x03\0\x08\x01m\x05\x02lo\x02le\x02la\x05ro-lo\x05ro-le\x04\0\x05\
+gadri\x03\0\x0a\x01m\x02\x03poi\x03noi\x04\0\x0frel-clause-kind\x03\0\x0c\x01r\x02\
+\x04kind\x0d\x0dbody-sentencey\x04\0\x0arel-clause\x03\0\x0e\x01o\x02\x0b\x01\x01\
+o\x02\x05\x03\x01o\x02\x03\x0f\x01q\x07\x09pro-sumti\x01s\0\x0bdescription\x01\x10\
+\0\x04name\x01s\0\x0equoted-literal\x01s\0\x0bunspecified\0\0\x06tagged\x01\x11\0\
+\x0arestricted\x01\x12\0\x04\0\x05sumti\x03\0\x13\x01ps\x01o\x02\x01\x01\x01o\x02\
+\x07\x01\x01p\x03\x01o\x02\x01\x18\x01o\x03\x01\x09\x01\x01q\x08\x04root\x01s\0\x08\
+compound\x01\x15\0\x05tanru\x01\x16\0\x09converted\x01\x17\0\x07negated\x01\x01\0\
+\x07grouped\x01\x01\0\x09with-args\x01\x19\0\x09connected\x01\x1a\0\x04\0\x06sel\
+bri\x03\0\x1b\x01r\x04\x08relation\x01\x0ahead-terms\x18\x0atail-terms\x18\x07ne\
+gated\x7f\x04\0\x05bridi\x03\0\x1d\x01p\x1c\x01p\x14\x01p\x1e\x01r\x03\x07selbri\
+s\x1f\x06sumtis\x20\x09sentences!\x04\0\x0aast-buffer\x03\0\"\x01q\x04\x08variab\
+le\x01s\0\x08constant\x01s\0\x0bdescription\x01s\0\x0bunspecified\0\0\x04\0\x0cl\
+ogical-term\x03\0$\x01p%\x01o\x02s&\x01o\x02yy\x01o\x02sy\x01q\x06\x09predicate\x01\
+'\0\x08and-node\x01(\0\x07or-node\x01(\0\x08not-node\x01y\0\x0bexists-node\x01)\0\
+\x0cfor-all-node\x01)\0\x04\0\x0alogic-node\x03\0*\x01p+\x01py\x01r\x02\x05nodes\
+,\x05roots-\x04\0\x0clogic-buffer\x03\0.\x03\0\x1blojban:nesy/ast-types@0.1.0\x05\
+\0\x02\x03\0\0\x0aast-buffer\x01B\x05\x02\x03\x02\x01\x01\x04\0\x0aast-buffer\x03\
+\0\0\x01j\x01\x01\x01s\x01@\x01\x05inputs\0\x02\x04\0\x0aparse-text\x01\x03\x03\0\
+\x18lojban:nesy/parser@0.1.0\x05\x02\x02\x03\0\0\x0clogic-buffer\x01B\x07\x02\x03\
+\x02\x01\x01\x04\0\x0aast-buffer\x03\0\0\x02\x03\x02\x01\x03\x04\0\x0clogic-buff\
+er\x03\0\x02\x01j\x01\x03\x01s\x01@\x01\x03ast\x01\0\x04\x04\0\x0ecompile-buffer\
+\x01\x05\x03\0\x1blojban:nesy/semantics@0.1.0\x05\x04\x01B\x08\x02\x03\x02\x01\x03\
+\x04\0\x0clogic-buffer\x03\0\0\x01j\0\x01s\x01@\x01\x05logic\x01\0\x02\x04\0\x0b\
+assert-fact\x01\x03\x01j\x01\x7f\x01s\x01@\x01\x05logic\x01\0\x04\x04\0\x10query\
+-entailment\x01\x05\x03\0\x1blojban:nesy/reasoning@0.1.0\x05\x05\x01j\x01y\x01s\x01\
+@\x01\x05inputs\0\x06\x04\0\x0bassert-text\x01\x07\x01j\x01\x7f\x01s\x01@\x01\x05\
+inputs\0\x08\x04\0\x0aquery-text\x01\x09\x01j\x01s\x01s\x01@\x01\x05inputs\0\x0a\
+\x04\0\x0dcompile-debug\x01\x0b\x04\0!lojban:nesy/engine-pipeline@0.1.0\x04\0\x0b\
+\x15\x01\0\x0fengine-pipeline\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0d\
+wit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
 #[inline(never)]
 #[doc(hidden)]
 pub fn __link_custom_section_describing_imports() {
diff --git a/parser/src/ast.rs b/parser/src/ast.rs
index 0c05185..2663fb0 100644
--- a/parser/src/ast.rs
+++ b/parser/src/ast.rs
@@ -9,7 +9,7 @@
 //   6. ke/ke'e tanru grouping
 //   7. je/ja/jo/ju connectives
 //   8. ku/vau/ku'o/kei terminators
-// Plus: se/te/ve/xe conversion, lo/le/la gadri, extended pro-sumti
+// Plus: se/te/ve/xe conversion, lo/le/la gadri, ro quantifier, extended pro-sumti
 
 // ─── Enums for grammatical markers ───────────────────────────────
 
@@ -56,9 +56,11 @@ pub enum Connective {
 /// Gadri (descriptor) type
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
 pub enum Gadri {
-    Lo, // veridical description (∃ in FOL)
-    Le, // non-veridical reference (specific referent)
-    La, // named entity (proper name)
+    Lo,   // veridical description (∃ in FOL)
+    Le,   // non-veridical reference (specific referent)
+    La,   // named entity (proper name)
+    RoLo, // universal veridical (∀ in FOL): ro lo
+    RoLe, // universal referential (∀ over specific set): ro le
 }
 
 /// Relative clause type
@@ -76,7 +78,7 @@ pub enum Sumti {
     /// Pro-sumti: mi, do, ko'a..ko'u, da/de/di, ti/ta/tu, ri/ra/ru, etc.
     ProSumti(String),
 
-    /// Gadri-description: lo/le/la + selbri [+ ku]
+    /// Gadri-description: lo/le/la/ro lo/ro le + selbri [+ ku]
     Description { gadri: Gadri, inner: Box<Selbri> },
 
     /// la + cmevla name(s)
diff --git a/parser/src/bindings.rs b/parser/src/bindings.rs
index d5a9946..c2ff3b6 100644
--- a/parser/src/bindings.rs
+++ b/parser/src/bindings.rs
@@ -130,6 +130,8 @@ pub mod lojban {
                 Lo,
                 Le,
                 La,
+                RoLo,
+                RoLe,
             }
             impl ::core::fmt::Debug for Gadri {
                 fn fmt(
@@ -140,6 +142,8 @@ pub mod lojban {
                         Gadri::Lo => f.debug_tuple("Gadri::Lo").finish(),
                         Gadri::Le => f.debug_tuple("Gadri::Le").finish(),
                         Gadri::La => f.debug_tuple("Gadri::La").finish(),
+                        Gadri::RoLo => f.debug_tuple("Gadri::RoLo").finish(),
+                        Gadri::RoLe => f.debug_tuple("Gadri::RoLe").finish(),
                     }
                 }
             }
@@ -153,6 +157,8 @@ pub mod lojban {
                         0 => Gadri::Lo,
                         1 => Gadri::Le,
                         2 => Gadri::La,
+                        3 => Gadri::RoLo,
+                        4 => Gadri::RoLe,
                         _ => panic!("invalid enum discriminant"),
                     }
                 }
@@ -1108,33 +1114,33 @@ pub(crate) use __export_parser_component_impl as export;
 )]
 #[doc(hidden)]
 #[allow(clippy::octal_escapes)]
-pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1136] = *b"\
-\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xe9\x07\x01A\x02\x01\
+pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1148] = *b"\
+\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xf5\x07\x01A\x02\x01\
 A\x05\x01B0\x01y\x04\0\x09selbri-id\x03\0\0\x01y\x04\0\x08sumti-id\x03\0\x02\x01\
 m\x05\x02fa\x02fe\x02fi\x02fo\x02fu\x04\0\x09place-tag\x03\0\x04\x01m\x04\x02se\x02\
 te\x02ve\x02xe\x04\0\x0aconversion\x03\0\x06\x01m\x04\x02je\x02ja\x02jo\x02ju\x04\
-\0\x0aconnective\x03\0\x08\x01m\x03\x02lo\x02le\x02la\x04\0\x05gadri\x03\0\x0a\x01\
-m\x02\x03poi\x03noi\x04\0\x0frel-clause-kind\x03\0\x0c\x01r\x02\x04kind\x0d\x0db\
-ody-sentencey\x04\0\x0arel-clause\x03\0\x0e\x01o\x02\x0b\x01\x01o\x02\x05\x03\x01\
-o\x02\x03\x0f\x01q\x07\x09pro-sumti\x01s\0\x0bdescription\x01\x10\0\x04name\x01s\
-\0\x0equoted-literal\x01s\0\x0bunspecified\0\0\x06tagged\x01\x11\0\x0arestricted\
-\x01\x12\0\x04\0\x05sumti\x03\0\x13\x01ps\x01o\x02\x01\x01\x01o\x02\x07\x01\x01p\
-\x03\x01o\x02\x01\x18\x01o\x03\x01\x09\x01\x01q\x08\x04root\x01s\0\x08compound\x01\
-\x15\0\x05tanru\x01\x16\0\x09converted\x01\x17\0\x07negated\x01\x01\0\x07grouped\
-\x01\x01\0\x09with-args\x01\x19\0\x09connected\x01\x1a\0\x04\0\x06selbri\x03\0\x1b\
-\x01r\x04\x08relation\x01\x0ahead-terms\x18\x0atail-terms\x18\x07negated\x7f\x04\
-\0\x05bridi\x03\0\x1d\x01p\x1c\x01p\x14\x01p\x1e\x01r\x03\x07selbris\x1f\x06sumt\
-is\x20\x09sentences!\x04\0\x0aast-buffer\x03\0\"\x01q\x04\x08variable\x01s\0\x08\
-constant\x01s\0\x0bdescription\x01s\0\x0bunspecified\0\0\x04\0\x0clogical-term\x03\
-\0$\x01p%\x01o\x02s&\x01o\x02yy\x01o\x02sy\x01q\x06\x09predicate\x01'\0\x08and-n\
-ode\x01(\0\x07or-node\x01(\0\x08not-node\x01y\0\x0bexists-node\x01)\0\x0cfor-all\
--node\x01)\0\x04\0\x0alogic-node\x03\0*\x01p+\x01py\x01r\x02\x05nodes,\x05roots-\
-\x04\0\x0clogic-buffer\x03\0.\x03\0\x1blojban:nesy/ast-types@0.1.0\x05\0\x02\x03\
-\0\0\x0aast-buffer\x01B\x05\x02\x03\x02\x01\x01\x04\0\x0aast-buffer\x03\0\0\x01j\
-\x01\x01\x01s\x01@\x01\x05inputs\0\x02\x04\0\x0aparse-text\x01\x03\x04\0\x18lojb\
-an:nesy/parser@0.1.0\x05\x02\x04\0\"lojban:nesy/parser-component@0.1.0\x04\0\x0b\
-\x16\x01\0\x10parser-component\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0d\
-wit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
+\0\x0aconnective\x03\0\x08\x01m\x05\x02lo\x02le\x02la\x05ro-lo\x05ro-le\x04\0\x05\
+gadri\x03\0\x0a\x01m\x02\x03poi\x03noi\x04\0\x0frel-clause-kind\x03\0\x0c\x01r\x02\
+\x04kind\x0d\x0dbody-sentencey\x04\0\x0arel-clause\x03\0\x0e\x01o\x02\x0b\x01\x01\
+o\x02\x05\x03\x01o\x02\x03\x0f\x01q\x07\x09pro-sumti\x01s\0\x0bdescription\x01\x10\
+\0\x04name\x01s\0\x0equoted-literal\x01s\0\x0bunspecified\0\0\x06tagged\x01\x11\0\
+\x0arestricted\x01\x12\0\x04\0\x05sumti\x03\0\x13\x01ps\x01o\x02\x01\x01\x01o\x02\
+\x07\x01\x01p\x03\x01o\x02\x01\x18\x01o\x03\x01\x09\x01\x01q\x08\x04root\x01s\0\x08\
+compound\x01\x15\0\x05tanru\x01\x16\0\x09converted\x01\x17\0\x07negated\x01\x01\0\
+\x07grouped\x01\x01\0\x09with-args\x01\x19\0\x09connected\x01\x1a\0\x04\0\x06sel\
+bri\x03\0\x1b\x01r\x04\x08relation\x01\x0ahead-terms\x18\x0atail-terms\x18\x07ne\
+gated\x7f\x04\0\x05bridi\x03\0\x1d\x01p\x1c\x01p\x14\x01p\x1e\x01r\x03\x07selbri\
+s\x1f\x06sumtis\x20\x09sentences!\x04\0\x0aast-buffer\x03\0\"\x01q\x04\x08variab\
+le\x01s\0\x08constant\x01s\0\x0bdescription\x01s\0\x0bunspecified\0\0\x04\0\x0cl\
+ogical-term\x03\0$\x01p%\x01o\x02s&\x01o\x02yy\x01o\x02sy\x01q\x06\x09predicate\x01\
+'\0\x08and-node\x01(\0\x07or-node\x01(\0\x08not-node\x01y\0\x0bexists-node\x01)\0\
+\x0cfor-all-node\x01)\0\x04\0\x0alogic-node\x03\0*\x01p+\x01py\x01r\x02\x05nodes\
+,\x05roots-\x04\0\x0clogic-buffer\x03\0.\x03\0\x1blojban:nesy/ast-types@0.1.0\x05\
+\0\x02\x03\0\0\x0aast-buffer\x01B\x05\x02\x03\x02\x01\x01\x04\0\x0aast-buffer\x03\
+\0\0\x01j\x01\x01\x01s\x01@\x01\x05inputs\0\x02\x04\0\x0aparse-text\x01\x03\x04\0\
+\x18lojban:nesy/parser@0.1.0\x05\x02\x04\0\"lojban:nesy/parser-component@0.1.0\x04\
+\0\x0b\x16\x01\0\x10parser-component\x03\0\0\0G\x09producers\x01\x0cprocessed-by\
+\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
 #[inline(never)]
 #[doc(hidden)]
 pub fn __link_custom_section_describing_imports() {
diff --git a/parser/src/grammar.rs b/parser/src/grammar.rs
index b0a4315..2c4c009 100644
--- a/parser/src/grammar.rs
+++ b/parser/src/grammar.rs
@@ -11,7 +11,7 @@
 //   sumti       → la_name | description | pro_sumti | quoted
 //                | sumti rel_clause
 //   la_name     → la cmevla+
-//   description → (lo|le) selbri ku?
+//   description → ro? (lo|le) selbri ku?
 //   rel_clause  → (poi|noi) sentence ku'o?
 //   selbri      → na? selbri_conn
 //   selbri_conn → selbri_2 ((je|ja|jo|ju) selbri_2)*
@@ -172,7 +172,6 @@ impl<'a> Parser<'a> {
     }
 
     /// Check if the current position is at a `.i` sentence separator.
-    /// Lojban `.i` is lexed as two tokens: Pause(".") + Cmavo("i").
     fn at_dot_i(&self) -> bool {
         if self.pos + 1 >= self.tokens.len() {
             return false;
@@ -186,17 +185,17 @@ impl<'a> Parser<'a> {
         )
     }
 
-    /// Consume a `.i` sentence separator if present. Returns true if consumed.
+    /// Consume a `.i` sentence separator if present.
     fn eat_dot_i(&mut self) -> bool {
         if self.at_dot_i() {
-            self.pos += 2; // consume both Pause and Cmavo("i")
+            self.pos += 2;
             true
         } else {
             false
         }
     }
 
-    /// Check if current token is a sentence boundary (for rel clause scoping).
+    /// Check if current token is a sentence boundary.
     fn at_sentence_boundary(&self) -> bool {
         if self.at_end() {
             return true;
@@ -213,17 +212,14 @@ impl<'a> Parser<'a> {
     pub fn parse_text(&mut self) -> Result<ParsedText, ParseError> {
         let mut sentences = Vec::new();
 
-        // Skip leading .i separators and pauses
         while self.eat_dot_i() || self.eat_pause() {}
 
         if self.at_end() {
             return Err(self.error("empty input"));
         }
 
-        // Parse first sentence
         sentences.push(self.parse_sentence()?);
 
-        // Parse subsequent .i-separated sentences
         loop {
             if !self.eat_dot_i() {
                 while self.eat_pause() {}
@@ -235,20 +231,19 @@ impl<'a> Parser<'a> {
             while self.eat_pause() {}
 
             if self.at_end() {
-                break; // trailing .i is fine
+                break;
             }
 
             if self.at_dot_i() {
-                continue; // doubled .i, skip
+                continue;
             }
 
             sentences.push(self.parse_sentence()?);
         }
 
-        // Skip trailing pauses
         while self.eat_pause() {}
 
-        // ── FIX #5: Detect unconsumed tokens ──
+        // Detect unconsumed tokens
         if !self.at_end() {
             let remaining = self.tokens.len() - self.pos;
             let next_desc = match self.peek() {
@@ -273,13 +268,10 @@ impl<'a> Parser<'a> {
 
     // ─── Sentence ─────────────────────────────────────────────
 
-    /// sentence → terms? cu? selbri tail? vau?
     fn parse_sentence(&mut self) -> Result<Bridi, ParseError> {
         self.enter()?;
 
         let head_terms = self.parse_terms();
-
-        // cu separator (optional)
         self.eat_cmavo("cu");
 
         let selbri = if let Some(s) = self.try_parse_selbri()? {
@@ -299,8 +291,6 @@ impl<'a> Parser<'a> {
         };
 
         let tail_terms = self.parse_terms();
-
-        // Optional vau terminator
         self.eat_cmavo("vau");
 
         self.leave();
@@ -335,16 +325,13 @@ impl<'a> Parser<'a> {
         terms
     }
 
-    /// term → place_tag? sumti
     fn try_parse_term(&mut self) -> Option<Sumti> {
-        // ── FIX #1: Save before consuming place tag ──
         let saved = self.save();
 
         if let Some(tag) = self.try_parse_place_tag() {
             if let Some(sumti) = self.try_parse_sumti() {
                 return Some(Sumti::Tagged(tag, Box::new(sumti)));
             }
-            // Tag consumed but no sumti — restore
             self.restore(saved);
             return None;
         }
@@ -385,6 +372,11 @@ impl<'a> Parser<'a> {
             return self.try_parse_la_name();
         }
 
+        // ── Phase 6b: ro lo / ro le (universal quantification) ──
+        if self.peek_is_cmavo("ro") {
+            return self.try_parse_ro_description();
+        }
+
         if self.peek_is_any_cmavo(&["lo", "le"]) {
             return self.try_parse_description();
         }
@@ -402,16 +394,54 @@ impl<'a> Parser<'a> {
         None
     }
 
-    /// la + cmevla+
+    /// ro (lo|le) selbri ku? — universal quantification
+    fn try_parse_ro_description(&mut self) -> Option<Sumti> {
+        if !self.peek_is_cmavo("ro") {
+            return None;
+        }
+
+        let saved = self.save();
+        self.pos += 1; // consume ro
+
+        // Must be followed by lo or le
+        let gadri = match self.peek_cmavo() {
+            Some("lo") => {
+                self.pos += 1;
+                Gadri::RoLo
+            }
+            Some("le") => {
+                self.pos += 1;
+                Gadri::RoLe
+            }
+            _ => {
+                self.restore(saved);
+                return None;
+            }
+        };
+
+        let selbri = match self.try_parse_selbri_for_description() {
+            Some(s) => s,
+            None => {
+                self.restore(saved);
+                return None;
+            }
+        };
+
+        self.eat_cmavo("ku");
+
+        Some(Sumti::Description {
+            gadri,
+            inner: Box::new(selbri),
+        })
+    }
+
     fn try_parse_la_name(&mut self) -> Option<Sumti> {
         if !self.peek_is_cmavo("la") {
             return None;
         }
 
-        // ── FIX #2: Save before consuming `la` ──
         let saved = self.save();
-        self.pos += 1; // consume la
-
+        self.pos += 1;
         self.eat_pause();
 
         let mut name_parts = Vec::new();
@@ -423,7 +453,6 @@ impl<'a> Parser<'a> {
         }
 
         if name_parts.is_empty() {
-            // la + selbri variant
             if let Some(selbri) = self.try_parse_selbri_for_description() {
                 self.eat_cmavo("ku");
                 return Some(Sumti::Description {
@@ -431,7 +460,6 @@ impl<'a> Parser<'a> {
                     inner: Box::new(selbri),
                 });
             }
-            // Total failure — restore
             self.restore(saved);
             return None;
         }
@@ -447,9 +475,8 @@ impl<'a> Parser<'a> {
             _ => return None,
         };
 
-        // ── FIX #3: Save before consuming gadri ──
         let saved = self.save();
-        self.pos += 1; // consume gadri
+        self.pos += 1;
 
         let selbri = match self.try_parse_selbri_for_description() {
             Some(s) => s,
@@ -491,7 +518,6 @@ impl<'a> Parser<'a> {
         Some(result)
     }
 
-    /// rel_clause → (poi|noi) sentence ku'o?
     fn try_parse_rel_clause(&mut self) -> Option<RelClause> {
         let kind = match self.peek_cmavo()? {
             "poi" => RelClauseKind::Poi,
@@ -499,9 +525,8 @@ impl<'a> Parser<'a> {
             _ => return None,
         };
 
-        // ── FIX #6: Save before consuming poi/noi ──
         let saved = self.save();
-        self.pos += 1; // consume poi/noi
+        self.pos += 1;
 
         let body = match self.parse_sentence() {
             Ok(bridi) => bridi,
@@ -570,7 +595,6 @@ impl<'a> Parser<'a> {
     }
 
     fn try_parse_selbri_2(&mut self) -> Option<Selbri> {
-        // ── FIX: Save before conversion in case tanru fails ──
         let saved = self.save();
         let conv = self.try_parse_conversion();
 
@@ -633,14 +657,12 @@ impl<'a> Parser<'a> {
     }
 
     fn try_parse_tanru_unit_base(&mut self) -> Option<Selbri> {
-        // ke ... ke'e (explicit grouping)
         if self.peek_is_cmavo("ke") {
-            // ── FIX #4: Depth guard on ke recursion ──
             if self.depth >= MAX_DEPTH {
                 return None;
             }
             let saved = self.save();
-            self.pos += 1; // consume ke
+            self.pos += 1;
 
             self.depth += 1;
             let inner = self.try_parse_tanru();
@@ -652,21 +674,18 @@ impl<'a> Parser<'a> {
                     return Some(Selbri::Grouped(Box::new(selbri)));
                 }
                 None => {
-                    // Restore on failed ke-group
                     self.restore(saved);
                     return None;
                 }
             }
         }
 
-        // Gismu (root word)
         if self.peek_is_gismu() {
             if let Some(NormalizedToken::Standard(_, s)) = self.advance() {
                 return Some(Selbri::Root(s.to_string()));
             }
         }
 
-        // Glued compound (from zei preprocessing)
         if let Some(NormalizedToken::Glued(parts)) = self.peek() {
             let compound: Vec<String> = parts.iter().map(|s| s.to_string()).collect();
             self.pos += 1;
@@ -715,7 +734,6 @@ impl<'a> Parser<'a> {
 
 // ─── Public entry point ───────────────────────────────────────────
 
-/// Parse a preprocessed token stream into a structured AST.
 pub fn parse_tokens_to_ast(tokens: &[NormalizedToken<'_>]) -> Result<ParsedText, String> {
     let mut parser = Parser::new(tokens);
     parser.parse_text().map_err(|e| e.to_string())
@@ -962,11 +980,10 @@ mod tests {
         assert_eq!(s.tail_terms[0], Sumti::Unspecified);
     }
 
-    // ─── Phase 5: hardening-specific tests ────────────────────
+    // ─── Phase 5 hardening tests ──────────────────────────────
 
     #[test]
     fn test_unconsumed_tokens_detected() {
-        // "klama" is selbri, ku'o is a stray terminator → unconsumed
         let tokens = [cmavo("mi"), gismu("klama"), cmavo("ku'o")];
         let result = parse_tokens_to_ast(&tokens);
         assert!(result.is_err());
@@ -975,7 +992,6 @@ mod tests {
 
     #[test]
     fn test_backtrack_place_tag_at_end() {
-        // "fa" at end — tag consumed but no sumti → should restore and error
         let tokens = [gismu("klama"), cmavo("fa")];
         let result = parse_tokens_to_ast(&tokens);
         assert!(result.is_err());
@@ -983,7 +999,6 @@ mod tests {
 
     #[test]
     fn test_backtrack_lo_without_selbri() {
-        // "lo" at end — gadri consumed but no selbri → should restore
         let tokens = [gismu("klama"), cmavo("lo")];
         let result = parse_tokens_to_ast(&tokens);
         assert!(result.is_err());
@@ -991,7 +1006,6 @@ mod tests {
 
     #[test]
     fn test_backtrack_la_without_name() {
-        // "la" at end — consumed but no cmevla → should restore
         let tokens = [gismu("klama"), cmavo("la")];
         let result = parse_tokens_to_ast(&tokens);
         assert!(result.is_err());
@@ -999,7 +1013,6 @@ mod tests {
 
     #[test]
     fn test_depth_limit_does_not_crash() {
-        // 100 nested ke's — should hit depth limit, not stack overflow
         let mut tokens: Vec<NormalizedToken<'static>> = Vec::new();
         tokens.push(cmavo("mi"));
         for _ in 0..100 {
@@ -1010,15 +1023,68 @@ mod tests {
             tokens.push(cmavo("ke'e"));
         }
         let result = parse_tokens_to_ast(&tokens);
-        // Must not panic/crash — error or degraded parse are both acceptable
         let _ = result;
     }
 
     #[test]
     fn test_backtrack_conversion_without_tanru() {
-        // "se" at end — conversion consumed but no tanru → should restore
         let tokens = [gismu("klama"), cmavo("se")];
         let result = parse_tokens_to_ast(&tokens);
         assert!(result.is_err());
     }
+
+    // ─── Phase 6b: ro quantifier tests ────────────────────────
+
+    #[test]
+    fn test_ro_lo_description() {
+        // ro lo gerku cu barda
+        let tokens = [
+            cmavo("ro"),
+            cmavo("lo"),
+            gismu("gerku"),
+            cmavo("cu"),
+            gismu("barda"),
+        ];
+        let result = parse_tokens_to_ast(&tokens).unwrap();
+        let s = &result.sentences[0];
+        assert_eq!(s.head_terms.len(), 1);
+        match &s.head_terms[0] {
+            Sumti::Description { gadri, inner } => {
+                assert_eq!(*gadri, Gadri::RoLo);
+                assert_eq!(**inner, Selbri::Root("gerku".into()));
+            }
+            other => panic!("expected Description(RoLo, ...), got {:?}", other),
+        }
+        assert_eq!(s.selbri, Selbri::Root("barda".into()));
+    }
+
+    #[test]
+    fn test_ro_le_description() {
+        // ro le mlatu cu cmalu
+        let tokens = [
+            cmavo("ro"),
+            cmavo("le"),
+            gismu("mlatu"),
+            cmavo("cu"),
+            gismu("cmalu"),
+        ];
+        let result = parse_tokens_to_ast(&tokens).unwrap();
+        let s = &result.sentences[0];
+        match &s.head_terms[0] {
+            Sumti::Description { gadri, .. } => assert_eq!(*gadri, Gadri::RoLe),
+            other => panic!("expected Description(RoLe, ...), got {:?}", other),
+        }
+    }
+
+    #[test]
+    fn test_ro_backtrack_without_gadri() {
+        // "ro" not followed by lo/le — should not consume ro
+        let tokens = [cmavo("ro"), gismu("klama")];
+        // ro is not a sumti, klama becomes selbri, no head terms
+        // Actually ro alone isn't consumed, klama becomes selbri
+        // This should either parse klama as selbri or error
+        let result = parse_tokens_to_ast(&tokens);
+        // ro not consumed → unconsumed token error
+        assert!(result.is_err());
+    }
 }
diff --git a/parser/src/lib.rs b/parser/src/lib.rs
index 5fdfa6e..7f300d2 100644
--- a/parser/src/lib.rs
+++ b/parser/src/lib.rs
@@ -162,6 +162,8 @@ impl Flattener {
                     ast::Gadri::Lo => wit::Gadri::Lo,
                     ast::Gadri::Le => wit::Gadri::Le,
                     ast::Gadri::La => wit::Gadri::La,
+                    ast::Gadri::RoLo => wit::Gadri::RoLo,
+                    ast::Gadri::RoLe => wit::Gadri::RoLe,
                 };
                 wit::Sumti::Description((wit_gadri, inner_id))
             }
diff --git a/reasoning/src/bindings.rs b/reasoning/src/bindings.rs
index e834cf0..9b47b25 100644
--- a/reasoning/src/bindings.rs
+++ b/reasoning/src/bindings.rs
@@ -130,6 +130,8 @@ pub mod lojban {
                 Lo,
                 Le,
                 La,
+                RoLo,
+                RoLe,
             }
             impl ::core::fmt::Debug for Gadri {
                 fn fmt(
@@ -140,6 +142,8 @@ pub mod lojban {
                         Gadri::Lo => f.debug_tuple("Gadri::Lo").finish(),
                         Gadri::Le => f.debug_tuple("Gadri::Le").finish(),
                         Gadri::La => f.debug_tuple("Gadri::La").finish(),
+                        Gadri::RoLo => f.debug_tuple("Gadri::RoLo").finish(),
+                        Gadri::RoLe => f.debug_tuple("Gadri::RoLe").finish(),
                     }
                 }
             }
@@ -153,6 +157,8 @@ pub mod lojban {
                         0 => Gadri::Lo,
                         1 => Gadri::Le,
                         2 => Gadri::La,
+                        3 => Gadri::RoLo,
+                        4 => Gadri::RoLe,
                         _ => panic!("invalid enum discriminant"),
                     }
                 }
@@ -1037,34 +1043,34 @@ pub(crate) use __export_reasoning_component_impl as export;
 )]
 #[doc(hidden)]
 #[allow(clippy::octal_escapes)]
-pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1188] = *b"\
-\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x9a\x08\x01A\x02\x01\
+pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1200] = *b"\
+\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xa6\x08\x01A\x02\x01\
 A\x05\x01B0\x01y\x04\0\x09selbri-id\x03\0\0\x01y\x04\0\x08sumti-id\x03\0\x02\x01\
 m\x05\x02fa\x02fe\x02fi\x02fo\x02fu\x04\0\x09place-tag\x03\0\x04\x01m\x04\x02se\x02\
 te\x02ve\x02xe\x04\0\x0aconversion\x03\0\x06\x01m\x04\x02je\x02ja\x02jo\x02ju\x04\
-\0\x0aconnective\x03\0\x08\x01m\x03\x02lo\x02le\x02la\x04\0\x05gadri\x03\0\x0a\x01\
-m\x02\x03poi\x03noi\x04\0\x0frel-clause-kind\x03\0\x0c\x01r\x02\x04kind\x0d\x0db\
-ody-sentencey\x04\0\x0arel-clause\x03\0\x0e\x01o\x02\x0b\x01\x01o\x02\x05\x03\x01\
-o\x02\x03\x0f\x01q\x07\x09pro-sumti\x01s\0\x0bdescription\x01\x10\0\x04name\x01s\
-\0\x0equoted-literal\x01s\0\x0bunspecified\0\0\x06tagged\x01\x11\0\x0arestricted\
-\x01\x12\0\x04\0\x05sumti\x03\0\x13\x01ps\x01o\x02\x01\x01\x01o\x02\x07\x01\x01p\
-\x03\x01o\x02\x01\x18\x01o\x03\x01\x09\x01\x01q\x08\x04root\x01s\0\x08compound\x01\
-\x15\0\x05tanru\x01\x16\0\x09converted\x01\x17\0\x07negated\x01\x01\0\x07grouped\
-\x01\x01\0\x09with-args\x01\x19\0\x09connected\x01\x1a\0\x04\0\x06selbri\x03\0\x1b\
-\x01r\x04\x08relation\x01\x0ahead-terms\x18\x0atail-terms\x18\x07negated\x7f\x04\
-\0\x05bridi\x03\0\x1d\x01p\x1c\x01p\x14\x01p\x1e\x01r\x03\x07selbris\x1f\x06sumt\
-is\x20\x09sentences!\x04\0\x0aast-buffer\x03\0\"\x01q\x04\x08variable\x01s\0\x08\
-constant\x01s\0\x0bdescription\x01s\0\x0bunspecified\0\0\x04\0\x0clogical-term\x03\
-\0$\x01p%\x01o\x02s&\x01o\x02yy\x01o\x02sy\x01q\x06\x09predicate\x01'\0\x08and-n\
-ode\x01(\0\x07or-node\x01(\0\x08not-node\x01y\0\x0bexists-node\x01)\0\x0cfor-all\
--node\x01)\0\x04\0\x0alogic-node\x03\0*\x01p+\x01py\x01r\x02\x05nodes,\x05roots-\
-\x04\0\x0clogic-buffer\x03\0.\x03\0\x1blojban:nesy/ast-types@0.1.0\x05\0\x02\x03\
-\0\0\x0clogic-buffer\x01B\x08\x02\x03\x02\x01\x01\x04\0\x0clogic-buffer\x03\0\0\x01\
-j\0\x01s\x01@\x01\x05logic\x01\0\x02\x04\0\x0bassert-fact\x01\x03\x01j\x01\x7f\x01\
-s\x01@\x01\x05logic\x01\0\x04\x04\0\x10query-entailment\x01\x05\x04\0\x1blojban:\
-nesy/reasoning@0.1.0\x05\x02\x04\0%lojban:nesy/reasoning-component@0.1.0\x04\0\x0b\
-\x19\x01\0\x13reasoning-component\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\
-\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
+\0\x0aconnective\x03\0\x08\x01m\x05\x02lo\x02le\x02la\x05ro-lo\x05ro-le\x04\0\x05\
+gadri\x03\0\x0a\x01m\x02\x03poi\x03noi\x04\0\x0frel-clause-kind\x03\0\x0c\x01r\x02\
+\x04kind\x0d\x0dbody-sentencey\x04\0\x0arel-clause\x03\0\x0e\x01o\x02\x0b\x01\x01\
+o\x02\x05\x03\x01o\x02\x03\x0f\x01q\x07\x09pro-sumti\x01s\0\x0bdescription\x01\x10\
+\0\x04name\x01s\0\x0equoted-literal\x01s\0\x0bunspecified\0\0\x06tagged\x01\x11\0\
+\x0arestricted\x01\x12\0\x04\0\x05sumti\x03\0\x13\x01ps\x01o\x02\x01\x01\x01o\x02\
+\x07\x01\x01p\x03\x01o\x02\x01\x18\x01o\x03\x01\x09\x01\x01q\x08\x04root\x01s\0\x08\
+compound\x01\x15\0\x05tanru\x01\x16\0\x09converted\x01\x17\0\x07negated\x01\x01\0\
+\x07grouped\x01\x01\0\x09with-args\x01\x19\0\x09connected\x01\x1a\0\x04\0\x06sel\
+bri\x03\0\x1b\x01r\x04\x08relation\x01\x0ahead-terms\x18\x0atail-terms\x18\x07ne\
+gated\x7f\x04\0\x05bridi\x03\0\x1d\x01p\x1c\x01p\x14\x01p\x1e\x01r\x03\x07selbri\
+s\x1f\x06sumtis\x20\x09sentences!\x04\0\x0aast-buffer\x03\0\"\x01q\x04\x08variab\
+le\x01s\0\x08constant\x01s\0\x0bdescription\x01s\0\x0bunspecified\0\0\x04\0\x0cl\
+ogical-term\x03\0$\x01p%\x01o\x02s&\x01o\x02yy\x01o\x02sy\x01q\x06\x09predicate\x01\
+'\0\x08and-node\x01(\0\x07or-node\x01(\0\x08not-node\x01y\0\x0bexists-node\x01)\0\
+\x0cfor-all-node\x01)\0\x04\0\x0alogic-node\x03\0*\x01p+\x01py\x01r\x02\x05nodes\
+,\x05roots-\x04\0\x0clogic-buffer\x03\0.\x03\0\x1blojban:nesy/ast-types@0.1.0\x05\
+\0\x02\x03\0\0\x0clogic-buffer\x01B\x08\x02\x03\x02\x01\x01\x04\0\x0clogic-buffe\
+r\x03\0\0\x01j\0\x01s\x01@\x01\x05logic\x01\0\x02\x04\0\x0bassert-fact\x01\x03\x01\
+j\x01\x7f\x01s\x01@\x01\x05logic\x01\0\x04\x04\0\x10query-entailment\x01\x05\x04\
+\0\x1blojban:nesy/reasoning@0.1.0\x05\x02\x04\0%lojban:nesy/reasoning-component@\
+0.1.0\x04\0\x0b\x19\x01\0\x13reasoning-component\x03\0\0\0G\x09producers\x01\x0c\
+processed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
 #[inline(never)]
 #[doc(hidden)]
 pub fn __link_custom_section_describing_imports() {
diff --git a/reasoning/src/lib.rs b/reasoning/src/lib.rs
index 1710c95..c94ffbf 100644
--- a/reasoning/src/lib.rs
+++ b/reasoning/src/lib.rs
@@ -12,11 +12,19 @@ use std::sync::{Mutex, OnceLock};
 static EGRAPH: OnceLock<Mutex<EGraph>> = OnceLock::new();
 static SKOLEM_COUNTER: OnceLock<Mutex<usize>> = OnceLock::new();
 static KNOWN_ENTITIES: OnceLock<Mutex<HashSet<String>>> = OnceLock::new();
+static UNIVERSAL_TEMPLATES: OnceLock<Mutex<Vec<UniversalTemplate>>> = OnceLock::new();
 
 /// Maximum combinations when resolving existential queries.
-/// For N entities and K existential variables, we try N^K substitutions.
 const MAX_QUERY_COMBOS: usize = 10_000;
 
+/// A stored universal formula for Herbrand instantiation.
+/// When new entities appear, we instantiate the template for each.
+struct UniversalTemplate {
+    var_name: String,
+    /// The body s-expression with (Var "var_name") as placeholder
+    body_sexp: String,
+}
+
 fn fresh_skolem() -> String {
     let counter = SKOLEM_COUNTER.get_or_init(|| Mutex::new(0));
     let mut c = counter.lock().unwrap();
@@ -25,9 +33,32 @@ fn fresh_skolem() -> String {
     sk
 }
 
-fn register_entity(name: &str) {
+/// Register an entity and instantiate all stored universals for it.
+/// Returns true if the entity was NEW (not previously known).
+fn register_entity(name: &str, egraph: &mut EGraph) -> bool {
     let entities = KNOWN_ENTITIES.get_or_init(|| Mutex::new(HashSet::new()));
-    entities.lock().unwrap().insert(name.to_string());
+    let is_new = entities.lock().unwrap().insert(name.to_string());
+
+    if is_new {
+        // Instantiate all stored universals for the new entity
+        let templates = UNIVERSAL_TEMPLATES.get_or_init(|| Mutex::new(Vec::new()));
+        let templates_guard = templates.lock().unwrap();
+        for tmpl in templates_guard.iter() {
+            let instantiated = tmpl.body_sexp.replace(
+                &format!("(Var \"{}\")", tmpl.var_name),
+                &format!("(Const \"{}\")", name),
+            );
+            let command = format!("(IsTrue {})", instantiated);
+            if let Err(e) = egraph.parse_and_run_program(None, &command) {
+                eprintln!(
+                    "[reasoning] Failed to instantiate universal for {}: {}",
+                    name, e
+                );
+            }
+        }
+    }
+
+    is_new
 }
 
 fn get_known_entities() -> Vec<String> {
@@ -42,7 +73,7 @@ fn get_egraph() -> &'static Mutex<EGraph> {
         let schema_str = r#"
             ;; ═══════════════════════════════════════════════
             ;; Lojban NeSy Engine — FOL Schema & Rules
-            ;; Phase 6: Skolemization-aware
+            ;; Phase 6b: Skolemization + Herbrand instantiation
             ;; ═══════════════════════════════════════════════
 
             ;; Atomic Terms
@@ -99,26 +130,24 @@ fn get_egraph() -> &'static Mutex<EGraph> {
             ;; INFERENCE RULES
             ;; ───────────────────────────────────────────────
 
-            ;; Conjunction Elimination: A ∧ B ⊢ A, B
+            ;; Conjunction Elimination
             (rule ((IsTrue (And A B)))
                   ((IsTrue A) (IsTrue B)))
 
-            ;; Disjunctive Syllogism: A ∨ B, ¬A ⊢ B
+            ;; Disjunctive Syllogism
             (rule ((IsTrue (Or A B)) (IsTrue (Not A)))
                   ((IsTrue B)))
 
-            ;; Modus Ponens: A → B, A ⊢ B
+            ;; Modus Ponens
             (rule ((IsTrue (Implies A B)) (IsTrue A))
                   ((IsTrue B)))
 
-            ;; Modus Tollens: A → B, ¬B ⊢ ¬A
+            ;; Modus Tollens
             (rule ((IsTrue (Implies A B)) (IsTrue (Not B)))
                   ((IsTrue (Not A))))
 
             ;; ───────────────────────────────────────────────
-            ;; QUANTIFIER RULES (legacy, for non-Skolemized data)
-            ;; After Phase 6, assertions are Skolemized so these
-            ;; only fire on residual or manually asserted formulas.
+            ;; QUANTIFIER RULES (residual)
             ;; ───────────────────────────────────────────────
 
             ;; ∃-distribution over ∧
@@ -143,31 +172,66 @@ fn get_egraph() -> &'static Mutex<EGraph> {
 struct ReasoningComponent;
 
 impl Guest for ReasoningComponent {
-    /// Assert facts with Skolemization.
-    ///
-    /// All existential quantifiers are replaced with fresh Skolem constants.
-    /// `∃x. gerku(x) ∧ barda(x)` becomes `gerku(sk_0) ∧ barda(sk_0)`.
-    /// This eliminates variable aliasing across independent assertions.
+    /// Assert facts with Skolemization (∃) and Herbrand instantiation (∀).
     fn assert_fact(logic: LogicBuffer) -> Result<(), String> {
         let egraph_mutex = get_egraph();
         let mut egraph = egraph_mutex.lock().unwrap();
 
         for &root_id in &logic.roots {
-            // Collect all ∃-bound variables and assign globally unique Skolem constants
+            // Phase 1: Collect existential variables for Skolemization
             let mut skolem_subs = HashMap::new();
             collect_exists_for_skolem(&logic, root_id, &mut skolem_subs);
 
-            // Register Skolem constants as known entities
+            // Register Skolem constants as entities
             for sk in skolem_subs.values() {
-                register_entity(sk);
+                register_entity(sk, &mut egraph);
             }
 
-            // Register any named constants (la .bob. → "bob")
-            collect_and_register_constants(&logic, root_id);
-
-            // Build Skolemized s-expression (∃ wrappers removed, vars → Const)
-            let sexp = reconstruct_sexp_with_subs(&logic, root_id, &skolem_subs);
+            // Register named constants as entities
+            collect_and_register_constants(&logic, root_id, &mut egraph);
+
+            // Phase 2: Check for ForAll nodes and handle Herbrand instantiation
+            let forall_entries = collect_forall_nodes(&logic, root_id, &skolem_subs);
+
+            if !forall_entries.is_empty() {
+                for (var_name, body_sexp) in &forall_entries {
+                    println!(
+                        "[Universal] ∀{} registered for Herbrand instantiation",
+                        var_name
+                    );
+
+                    // Store template for future entity registration
+                    let templates = UNIVERSAL_TEMPLATES.get_or_init(|| Mutex::new(Vec::new()));
+                    templates.lock().unwrap().push(UniversalTemplate {
+                        var_name: var_name.clone(),
+                        body_sexp: body_sexp.clone(),
+                    });
+
+                    // Instantiate for all currently known entities
+                    let entities = get_known_entities();
+                    for entity in &entities {
+                        let instantiated = body_sexp.replace(
+                            &format!("(Var \"{}\")", var_name),
+                            &format!("(Const \"{}\")", entity),
+                        );
+                        let command = format!("(IsTrue {})", instantiated);
+                        if let Err(e) = egraph.parse_and_run_program(None, &command) {
+                            return Err(format!(
+                                "Failed to instantiate universal for {}: {}",
+                                entity, e
+                            ));
+                        }
+                    }
+                    if !entities.is_empty() {
+                        println!(
+                            "[Universal] Instantiated for {} known entities",
+                            entities.len()
+                        );
+                    }
+                }
+            }
 
+            // Phase 3: Assert the (possibly Skolemized) formula itself
             if !skolem_subs.is_empty() {
                 println!(
                     "[Skolem] {} variable(s) → {}",
@@ -180,6 +244,7 @@ impl Guest for ReasoningComponent {
                 );
             }
 
+            let sexp = reconstruct_sexp_with_subs(&logic, root_id, &skolem_subs);
             let command = format!("(IsTrue {})", sexp);
             if let Err(e) = egraph.parse_and_run_program(None, &command) {
                 return Err(format!("Failed to assert fact: {}", e));
@@ -188,19 +253,12 @@ impl Guest for ReasoningComponent {
         Ok(())
     }
 
-    /// Query entailment with existential resolution.
-    ///
-    /// For queries without existentials (e.g., `la .bob. cu klama`):
-    ///   Direct structural check.
-    ///
-    /// For queries with existentials (e.g., `lo gerku cu barda`):
-    ///   Tries all known entity substitutions for each ∃-variable.
-    ///   Returns TRUE if any assignment satisfies the query.
+    /// Query entailment with existential and universal resolution.
     fn query_entailment(logic: LogicBuffer) -> Result<bool, String> {
         let egraph_mutex = get_egraph();
         let mut egraph = egraph_mutex.lock().unwrap();
 
-        // Saturate inference rules to fixpoint
+        // Saturate
         if let Err(e) = egraph.parse_and_run_program(None, "(run-schedule (saturate (run)))") {
             eprintln!(
                 "[reasoning] saturate failed, falling back to bounded run: {}",
@@ -212,28 +270,41 @@ impl Guest for ReasoningComponent {
         }
 
         for &root_id in &logic.roots {
-            // Collect existential variables in this query root
             let exist_vars = collect_exists_vars(&logic, root_id);
+            let forall_vars = collect_forall_vars(&logic, root_id);
 
-            if exist_vars.is_empty() {
-                // ── No existentials: direct structural check ──
-                let sexp = reconstruct_sexp(&logic, root_id);
-                let command = format!("(check (IsTrue {}))", sexp);
-                match egraph.parse_and_run_program(None, &command) {
-                    Ok(_) => {} // This root checks out
-                    Err(e) => {
-                        let msg = e.to_string();
-                        if msg.contains("Check failed") {
-                            return Ok(false);
+            if !forall_vars.is_empty() {
+                // ── Universal query: ALL entities must satisfy ──
+                let entities = get_known_entities();
+                if entities.is_empty() {
+                    // Vacuously true: ∀x.P(x) is true when domain is empty
+                    continue;
+                }
+
+                for entity in &entities {
+                    let mut subs = HashMap::new();
+                    for var in &forall_vars {
+                        subs.insert(var.clone(), entity.clone());
+                    }
+                    let sexp = reconstruct_sexp_with_subs(&logic, root_id, &subs);
+                    let command = format!("(check (IsTrue {}))", sexp);
+                    match egraph.parse_and_run_program(None, &command) {
+                        Ok(_) => {} // This entity satisfies
+                        Err(e) => {
+                            let msg = e.to_string();
+                            if msg.contains("Check failed") {
+                                return Ok(false); // One entity fails → ∀ is false
+                            }
+                            return Err(format!("Reasoning error: {}", msg));
                         }
-                        return Err(format!("Reasoning error: {}", msg));
                     }
                 }
-            } else {
-                // ── Has existentials: try Skolem constant substitutions ──
+                // All entities satisfied
+            } else if !exist_vars.is_empty() {
+                // ── Existential query: ANY entity must satisfy ──
                 let entities = get_known_entities();
                 if entities.is_empty() {
-                    return Ok(false); // No entities in KB → can't satisfy ∃
+                    return Ok(false);
                 }
 
                 let found = try_existential_resolution(
@@ -246,6 +317,20 @@ impl Guest for ReasoningComponent {
                 if !found {
                     return Ok(false);
                 }
+            } else {
+                // ── No quantifiers: direct structural check ──
+                let sexp = reconstruct_sexp(&logic, root_id);
+                let command = format!("(check (IsTrue {}))", sexp);
+                match egraph.parse_and_run_program(None, &command) {
+                    Ok(_) => {}
+                    Err(e) => {
+                        let msg = e.to_string();
+                        if msg.contains("Check failed") {
+                            return Ok(false);
+                        }
+                        return Err(format!("Reasoning error: {}", msg));
+                    }
+                }
             }
         }
 
@@ -255,7 +340,6 @@ impl Guest for ReasoningComponent {
 
 // ─── Skolemization Helpers ────────────────────────────────────
 
-/// Walk the logic tree and assign a fresh Skolem constant to each ∃-bound variable.
 fn collect_exists_for_skolem(
     buffer: &LogicBuffer,
     node_id: u32,
@@ -282,7 +366,6 @@ fn collect_exists_for_skolem(
     }
 }
 
-/// Collect names of all ∃-bound variables in the formula (for query resolution).
 fn collect_exists_vars(buffer: &LogicBuffer, node_id: u32) -> Vec<String> {
     let mut vars = Vec::new();
     collect_exists_vars_rec(buffer, node_id, &mut vars);
@@ -311,32 +394,94 @@ fn collect_exists_vars_rec(buffer: &LogicBuffer, node_id: u32, vars: &mut Vec<St
     }
 }
 
+/// Collect ForAll-bound variable names from a formula.
+fn collect_forall_vars(buffer: &LogicBuffer, node_id: u32) -> Vec<String> {
+    let mut vars = Vec::new();
+    collect_forall_vars_rec(buffer, node_id, &mut vars);
+    vars
+}
+
+fn collect_forall_vars_rec(buffer: &LogicBuffer, node_id: u32, vars: &mut Vec<String>) {
+    match &buffer.nodes[node_id as usize] {
+        LogicNode::ForAllNode((v, body)) => {
+            if !vars.contains(v) {
+                vars.push(v.clone());
+            }
+            collect_forall_vars_rec(buffer, *body, vars);
+        }
+        LogicNode::ExistsNode((_, body)) => {
+            collect_forall_vars_rec(buffer, *body, vars);
+        }
+        LogicNode::AndNode((l, r)) | LogicNode::OrNode((l, r)) => {
+            collect_forall_vars_rec(buffer, *l, vars);
+            collect_forall_vars_rec(buffer, *r, vars);
+        }
+        LogicNode::NotNode(inner) => {
+            collect_forall_vars_rec(buffer, *inner, vars);
+        }
+        LogicNode::Predicate(_) => {}
+    }
+}
+
+/// Extract ForAll nodes: returns (var_name, body_sexp) pairs.
+/// The body_sexp has the ForAll wrapper stripped and existentials Skolemized.
+fn collect_forall_nodes(
+    buffer: &LogicBuffer,
+    node_id: u32,
+    skolem_subs: &HashMap<String, String>,
+) -> Vec<(String, String)> {
+    let mut entries = Vec::new();
+    collect_forall_nodes_rec(buffer, node_id, skolem_subs, &mut entries);
+    entries
+}
+
+fn collect_forall_nodes_rec(
+    buffer: &LogicBuffer,
+    node_id: u32,
+    skolem_subs: &HashMap<String, String>,
+    entries: &mut Vec<(String, String)>,
+) {
+    match &buffer.nodes[node_id as usize] {
+        LogicNode::ForAllNode((v, body)) => {
+            let body_sexp = reconstruct_sexp_with_subs(buffer, *body, skolem_subs);
+            entries.push((v.clone(), body_sexp));
+            // Don't recurse into body — the template is the complete body
+        }
+        LogicNode::AndNode((l, r)) | LogicNode::OrNode((l, r)) => {
+            collect_forall_nodes_rec(buffer, *l, skolem_subs, entries);
+            collect_forall_nodes_rec(buffer, *r, skolem_subs, entries);
+        }
+        LogicNode::NotNode(inner) | LogicNode::ExistsNode((_, inner)) => {
+            collect_forall_nodes_rec(buffer, *inner, skolem_subs, entries);
+        }
+        _ => {}
+    }
+}
+
 /// Register all Const terms found in the formula as known entities.
-fn collect_and_register_constants(buffer: &LogicBuffer, node_id: u32) {
+fn collect_and_register_constants(buffer: &LogicBuffer, node_id: u32, egraph: &mut EGraph) {
     match &buffer.nodes[node_id as usize] {
         LogicNode::Predicate((_, args)) => {
             for arg in args {
                 if let LogicalTerm::Constant(c) = arg {
-                    register_entity(c);
+                    register_entity(c, egraph);
                 }
             }
         }
         LogicNode::AndNode((l, r)) | LogicNode::OrNode((l, r)) => {
-            collect_and_register_constants(buffer, *l);
-            collect_and_register_constants(buffer, *r);
+            collect_and_register_constants(buffer, *l, egraph);
+            collect_and_register_constants(buffer, *r, egraph);
         }
         LogicNode::NotNode(inner)
         | LogicNode::ExistsNode((_, inner))
         | LogicNode::ForAllNode((_, inner)) => {
-            collect_and_register_constants(buffer, *inner);
+            collect_and_register_constants(buffer, *inner, egraph);
         }
     }
 }
 
 // ─── Existential Query Resolution ─────────────────────────────
 
-/// Try all combinations of known entities for existential variables.
-/// Returns true if any substitution satisfies the query.
 fn try_existential_resolution(
     buffer: &LogicBuffer,
     root_id: u32,
@@ -347,42 +492,35 @@ fn try_existential_resolution(
     let n = entities.len();
     let k = exist_vars.len();
 
-    // Check combinatorial bound
     let total = n.checked_pow(k as u32).unwrap_or(usize::MAX);
     if total > MAX_QUERY_COMBOS {
         return Err(format!(
-            "Existential query too complex: {} variables × {} entities = {} combinations (limit {}). \
-             Narrow the query or assert fewer entities.",
+            "Existential query too complex: {} variables × {} entities = {} combinations (limit {})",
             k, n, total, MAX_QUERY_COMBOS
         ));
     }
 
-    // Iterate through all entity combinations (odometer algorithm)
     let mut indices = vec![0usize; k];
 
     loop {
-        // Build substitution: exist_var[i] → entities[indices[i]]
         let mut subs = HashMap::with_capacity(k);
         for (i, var) in exist_vars.iter().enumerate() {
             subs.insert(var.clone(), entities[indices[i]].clone());
         }
 
-        // Build substituted s-expression and check
         let sexp = reconstruct_sexp_with_subs(buffer, root_id, &subs);
         let command = format!("(check (IsTrue {}))", sexp);
 
         match egraph.parse_and_run_program(None, &command) {
-            Ok(_) => return Ok(true), // Found a satisfying assignment
+            Ok(_) => return Ok(true),
             Err(e) => {
                 let msg = e.to_string();
                 if !msg.contains("Check failed") {
                     return Err(format!("Reasoning error: {}", msg));
                 }
-                // This combination failed — try next
             }
         }
 
-        // Increment odometer (rightmost index first)
         let mut carry = true;
         for i in (0..k).rev() {
             if carry {
@@ -395,7 +533,7 @@ fn try_existential_resolution(
             }
         }
         if carry {
-            break; // All combinations exhausted
+            break;
         }
     }
 
@@ -404,11 +542,6 @@ fn try_existential_resolution(
 
 // ─── S-Expression Reconstruction ──────────────────────────────
 
-/// Reconstruct s-expression with variable substitutions.
-///
-/// When a substitution exists for an ∃-bound variable:
-/// - The `Exists` wrapper is removed (Skolemized away)
-/// - All `Variable(v)` occurrences become `Const(substitute)`
 fn reconstruct_sexp_with_subs(
     buffer: &LogicBuffer,
     node_id: u32,
@@ -421,7 +554,6 @@ fn reconstruct_sexp_with_subs(
                 let term_str = match arg {
                     LogicalTerm::Variable(v) => {
                         if let Some(replacement) = subs.get(v.as_str()) {
-                            // Substituted: variable → constant
                             format!("(Const \"{}\")", replacement)
                         } else {
                             format!("(Var \"{}\")", v)
@@ -437,7 +569,6 @@ fn reconstruct_sexp_with_subs(
         }
         LogicNode::ExistsNode((v, body)) => {
             if subs.contains_key(v.as_str()) {
-                // Skolemized: strip Exists wrapper, body carries the substitution
                 reconstruct_sexp_with_subs(buffer, *body, subs)
             } else {
                 format!(
@@ -448,11 +579,16 @@ fn reconstruct_sexp_with_subs(
             }
         }
         LogicNode::ForAllNode((v, body)) => {
-            format!(
-                "(ForAll \"{}\" {})",
-                v,
+            if subs.contains_key(v.as_str()) {
+                // Universal variable substituted — strip ForAll wrapper
                 reconstruct_sexp_with_subs(buffer, *body, subs)
-            )
+            } else {
+                format!(
+                    "(ForAll \"{}\" {})",
+                    v,
+                    reconstruct_sexp_with_subs(buffer, *body, subs)
+                )
+            }
         }
         LogicNode::AndNode((l, r)) => {
             format!(
@@ -474,8 +610,6 @@ fn reconstruct_sexp_with_subs(
     }
 }
 
-/// Original s-expression reconstruction (no substitutions).
-/// Used for non-existential queries.
 fn reconstruct_sexp(buffer: &LogicBuffer, node_id: u32) -> String {
     reconstruct_sexp_with_subs(buffer, node_id, &HashMap::new())
 }
diff --git a/semantics/src/bindings.rs b/semantics/src/bindings.rs
index fe93642..707ecf5 100644
--- a/semantics/src/bindings.rs
+++ b/semantics/src/bindings.rs
@@ -130,6 +130,8 @@ pub mod lojban {
                 Lo,
                 Le,
                 La,
+                RoLo,
+                RoLe,
             }
             impl ::core::fmt::Debug for Gadri {
                 fn fmt(
@@ -140,6 +142,8 @@ pub mod lojban {
                         Gadri::Lo => f.debug_tuple("Gadri::Lo").finish(),
                         Gadri::Le => f.debug_tuple("Gadri::Le").finish(),
                         Gadri::La => f.debug_tuple("Gadri::La").finish(),
+                        Gadri::RoLo => f.debug_tuple("Gadri::RoLo").finish(),
+                        Gadri::RoLe => f.debug_tuple("Gadri::RoLe").finish(),
                     }
                 }
             }
@@ -153,6 +157,8 @@ pub mod lojban {
                         0 => Gadri::Lo,
                         1 => Gadri::Le,
                         2 => Gadri::La,
+                        3 => Gadri::RoLo,
+                        4 => Gadri::RoLe,
                         _ => panic!("invalid enum discriminant"),
                     }
                 }
@@ -1300,34 +1306,34 @@ pub(crate) use __export_semantics_component_impl as export;
 )]
 #[doc(hidden)]
 #[allow(clippy::octal_escapes)]
-pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1187] = *b"\
-\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x99\x08\x01A\x02\x01\
+pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1199] = *b"\
+\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xa5\x08\x01A\x02\x01\
 A\x06\x01B0\x01y\x04\0\x09selbri-id\x03\0\0\x01y\x04\0\x08sumti-id\x03\0\x02\x01\
 m\x05\x02fa\x02fe\x02fi\x02fo\x02fu\x04\0\x09place-tag\x03\0\x04\x01m\x04\x02se\x02\
 te\x02ve\x02xe\x04\0\x0aconversion\x03\0\x06\x01m\x04\x02je\x02ja\x02jo\x02ju\x04\
-\0\x0aconnective\x03\0\x08\x01m\x03\x02lo\x02le\x02la\x04\0\x05gadri\x03\0\x0a\x01\
-m\x02\x03poi\x03noi\x04\0\x0frel-clause-kind\x03\0\x0c\x01r\x02\x04kind\x0d\x0db\
-ody-sentencey\x04\0\x0arel-clause\x03\0\x0e\x01o\x02\x0b\x01\x01o\x02\x05\x03\x01\
-o\x02\x03\x0f\x01q\x07\x09pro-sumti\x01s\0\x0bdescription\x01\x10\0\x04name\x01s\
-\0\x0equoted-literal\x01s\0\x0bunspecified\0\0\x06tagged\x01\x11\0\x0arestricted\
-\x01\x12\0\x04\0\x05sumti\x03\0\x13\x01ps\x01o\x02\x01\x01\x01o\x02\x07\x01\x01p\
-\x03\x01o\x02\x01\x18\x01o\x03\x01\x09\x01\x01q\x08\x04root\x01s\0\x08compound\x01\
-\x15\0\x05tanru\x01\x16\0\x09converted\x01\x17\0\x07negated\x01\x01\0\x07grouped\
-\x01\x01\0\x09with-args\x01\x19\0\x09connected\x01\x1a\0\x04\0\x06selbri\x03\0\x1b\
-\x01r\x04\x08relation\x01\x0ahead-terms\x18\x0atail-terms\x18\x07negated\x7f\x04\
-\0\x05bridi\x03\0\x1d\x01p\x1c\x01p\x14\x01p\x1e\x01r\x03\x07selbris\x1f\x06sumt\
-is\x20\x09sentences!\x04\0\x0aast-buffer\x03\0\"\x01q\x04\x08variable\x01s\0\x08\
-constant\x01s\0\x0bdescription\x01s\0\x0bunspecified\0\0\x04\0\x0clogical-term\x03\
-\0$\x01p%\x01o\x02s&\x01o\x02yy\x01o\x02sy\x01q\x06\x09predicate\x01'\0\x08and-n\
-ode\x01(\0\x07or-node\x01(\0\x08not-node\x01y\0\x0bexists-node\x01)\0\x0cfor-all\
--node\x01)\0\x04\0\x0alogic-node\x03\0*\x01p+\x01py\x01r\x02\x05nodes,\x05roots-\
-\x04\0\x0clogic-buffer\x03\0.\x03\0\x1blojban:nesy/ast-types@0.1.0\x05\0\x02\x03\
-\0\0\x0aast-buffer\x02\x03\0\0\x0clogic-buffer\x01B\x07\x02\x03\x02\x01\x01\x04\0\
-\x0aast-buffer\x03\0\0\x02\x03\x02\x01\x02\x04\0\x0clogic-buffer\x03\0\x02\x01j\x01\
-\x03\x01s\x01@\x01\x03ast\x01\0\x04\x04\0\x0ecompile-buffer\x01\x05\x04\0\x1bloj\
-ban:nesy/semantics@0.1.0\x05\x03\x04\0%lojban:nesy/semantics-component@0.1.0\x04\
-\0\x0b\x19\x01\0\x13semantics-component\x03\0\0\0G\x09producers\x01\x0cprocessed\
--by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
+\0\x0aconnective\x03\0\x08\x01m\x05\x02lo\x02le\x02la\x05ro-lo\x05ro-le\x04\0\x05\
+gadri\x03\0\x0a\x01m\x02\x03poi\x03noi\x04\0\x0frel-clause-kind\x03\0\x0c\x01r\x02\
+\x04kind\x0d\x0dbody-sentencey\x04\0\x0arel-clause\x03\0\x0e\x01o\x02\x0b\x01\x01\
+o\x02\x05\x03\x01o\x02\x03\x0f\x01q\x07\x09pro-sumti\x01s\0\x0bdescription\x01\x10\
+\0\x04name\x01s\0\x0equoted-literal\x01s\0\x0bunspecified\0\0\x06tagged\x01\x11\0\
+\x0arestricted\x01\x12\0\x04\0\x05sumti\x03\0\x13\x01ps\x01o\x02\x01\x01\x01o\x02\
+\x07\x01\x01p\x03\x01o\x02\x01\x18\x01o\x03\x01\x09\x01\x01q\x08\x04root\x01s\0\x08\
+compound\x01\x15\0\x05tanru\x01\x16\0\x09converted\x01\x17\0\x07negated\x01\x01\0\
+\x07grouped\x01\x01\0\x09with-args\x01\x19\0\x09connected\x01\x1a\0\x04\0\x06sel\
+bri\x03\0\x1b\x01r\x04\x08relation\x01\x0ahead-terms\x18\x0atail-terms\x18\x07ne\
+gated\x7f\x04\0\x05bridi\x03\0\x1d\x01p\x1c\x01p\x14\x01p\x1e\x01r\x03\x07selbri\
+s\x1f\x06sumtis\x20\x09sentences!\x04\0\x0aast-buffer\x03\0\"\x01q\x04\x08variab\
+le\x01s\0\x08constant\x01s\0\x0bdescription\x01s\0\x0bunspecified\0\0\x04\0\x0cl\
+ogical-term\x03\0$\x01p%\x01o\x02s&\x01o\x02yy\x01o\x02sy\x01q\x06\x09predicate\x01\
+'\0\x08and-node\x01(\0\x07or-node\x01(\0\x08not-node\x01y\0\x0bexists-node\x01)\0\
+\x0cfor-all-node\x01)\0\x04\0\x0alogic-node\x03\0*\x01p+\x01py\x01r\x02\x05nodes\
+,\x05roots-\x04\0\x0clogic-buffer\x03\0.\x03\0\x1blojban:nesy/ast-types@0.1.0\x05\
+\0\x02\x03\0\0\x0aast-buffer\x02\x03\0\0\x0clogic-buffer\x01B\x07\x02\x03\x02\x01\
+\x01\x04\0\x0aast-buffer\x03\0\0\x02\x03\x02\x01\x02\x04\0\x0clogic-buffer\x03\0\
+\x02\x01j\x01\x03\x01s\x01@\x01\x03ast\x01\0\x04\x04\0\x0ecompile-buffer\x01\x05\
+\x04\0\x1blojban:nesy/semantics@0.1.0\x05\x03\x04\0%lojban:nesy/semantics-compon\
+ent@0.1.0\x04\0\x0b\x19\x01\0\x13semantics-component\x03\0\0\0G\x09producers\x01\
+\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
 #[inline(never)]
 #[doc(hidden)]
 pub fn __link_custom_section_describing_imports() {
diff --git a/semantics/src/semantic.rs b/semantics/src/semantic.rs
index bb9ebd5..71b2c2c 100644
--- a/semantics/src/semantic.rs
+++ b/semantics/src/semantic.rs
@@ -5,12 +5,14 @@ use crate::dictionary::JbovlasteSchema;
 use crate::ir::{LogicalForm, LogicalTerm};
 use lasso::Rodeo;
 
-/// Tracks a quantifier introduced by a `lo` description,
+/// Tracks a quantifier introduced by a description (lo/le/ro lo/ro le),
 /// with an optional relative clause restrictor.
 struct QuantifierEntry {
     var: lasso::Spur,
     desc_id: u32,
     restrictor: Option<LogicalForm>,
+    /// If true, wraps as ∀x.(restrictor → body) instead of ∃x.(restrictor ∧ body)
+    universal: bool,
 }
 
 pub struct SemanticCompiler {
@@ -34,7 +36,6 @@ impl SemanticCompiler {
 
     // ─── Selbri Introspection ────────────────────────────────────
 
-    /// Recursively extracts the arity of the structural head of the relation.
     fn get_selbri_arity(&self, selbri_id: u32, selbris: &[Selbri]) -> usize {
         match &selbris[selbri_id as usize] {
             Selbri::Root(g) => JbovlasteSchema::get_arity_or_default(g.as_str()),
@@ -51,7 +52,6 @@ impl SemanticCompiler {
         }
     }
 
-    /// Extracts the string name of the structural head (for non-quantified descriptions).
     fn get_selbri_head_name<'a>(&self, selbri_id: u32, selbris: &'a [Selbri]) -> &'a str {
         match &selbris[selbri_id as usize] {
             Selbri::Root(r) => r.as_str(),
@@ -67,7 +67,6 @@ impl SemanticCompiler {
 
     // ─── Sumti Resolution ────────────────────────────────────────
 
-    /// Resolve a single sumti into a LogicalTerm, collecting any quantifier entries generated.
     fn resolve_sumti(
         &mut self,
         sumti: &Sumti,
@@ -91,39 +90,55 @@ impl SemanticCompiler {
             ),
 
             Sumti::Description((gadri, desc_id)) => {
-                if matches!(gadri, Gadri::Lo) {
-                    let var = self.fresh_var();
-                    (
-                        LogicalTerm::Variable(var),
-                        vec![QuantifierEntry {
-                            var,
-                            desc_id: *desc_id,
-                            restrictor: None,
-                        }],
-                    )
-                } else {
-                    // le/la descriptions: non-quantified specific referent
-                    let desc_str = self.get_selbri_head_name(*desc_id, selbris);
-                    (
-                        LogicalTerm::Description(self.interner.get_or_intern(desc_str)),
-                        vec![],
-                    )
+                match gadri {
+                    // Existential: lo → ∃x
+                    Gadri::Lo => {
+                        let var = self.fresh_var();
+                        (
+                            LogicalTerm::Variable(var),
+                            vec![QuantifierEntry {
+                                var,
+                                desc_id: *desc_id,
+                                restrictor: None,
+                                universal: false,
+                            }],
+                        )
+                    }
+
+                    // Universal: ro lo → ∀x, ro le → ∀x
+                    Gadri::RoLo | Gadri::RoLe => {
+                        let var = self.fresh_var();
+                        (
+                            LogicalTerm::Variable(var),
+                            vec![QuantifierEntry {
+                                var,
+                                desc_id: *desc_id,
+                                restrictor: None,
+                                universal: true,
+                            }],
+                        )
+                    }
+
+                    // le/la: non-quantified specific referent
+                    _ => {
+                        let desc_str = self.get_selbri_head_name(*desc_id, selbris);
+                        (
+                            LogicalTerm::Description(self.interner.get_or_intern(desc_str)),
+                            vec![],
+                        )
+                    }
                 }
             }
 
-            // FIX 1.3: Tagged sumti — resolve the inner sumti.
-            // Positional assignment is handled by compile_bridi, not here.
             Sumti::Tagged((_tag, inner_id)) => {
                 let inner = &sumtis[*inner_id as usize];
                 self.resolve_sumti(inner, sumtis, selbris, sentences)
             }
 
-            // FIX 1.4: Restricted sumti — resolve inner + compile relative clause.
             Sumti::Restricted((inner_id, rel_clause)) => {
                 let inner = &sumtis[*inner_id as usize];
                 let (term, mut quants) = self.resolve_sumti(inner, sumtis, selbris, sentences);
 
-                // Compile the relative clause body as a full bridi
                 let rel_body = self.compile_bridi(
                     &sentences[rel_clause.body_sentence as usize],
                     selbris,
@@ -131,13 +146,9 @@ impl SemanticCompiler {
                     sentences,
                 );
 
-                // Inject the bound variable as x1 of the restrictor and attach
-                // to the most recent quantifier (the one created by the inner sumti).
                 if let Some(last) = quants.last_mut() {
                     last.restrictor = Some(Self::inject_variable(rel_body, last.var));
                 }
-                // If no quantifier exists (e.g., "mi poi barda"), the restrictor
-                // is dropped. This is rare and semantically unusual.
 
                 (term, quants)
             }
@@ -151,9 +162,6 @@ impl SemanticCompiler {
         }
     }
 
-    /// Inject a variable as x1 of a logical form, replacing Unspecified in
-    /// the first argument position. Used to bind relative clause restrictors
-    /// to their head noun's variable.
     fn inject_variable(form: LogicalForm, var: lasso::Spur) -> LogicalForm {
         match form {
             LogicalForm::Predicate { relation, mut args } => {
@@ -164,7 +172,6 @@ impl SemanticCompiler {
                 }
                 LogicalForm::Predicate { relation, args }
             }
-            // Tanru produce And — inject into both branches
             LogicalForm::And(l, r) => LogicalForm::And(
                 Box::new(Self::inject_variable(*l, var)),
                 Box::new(Self::inject_variable(*r, var)),
@@ -172,16 +179,12 @@ impl SemanticCompiler {
             LogicalForm::Not(inner) => {
                 LogicalForm::Not(Box::new(Self::inject_variable(*inner, var)))
             }
-            // Quantifiers, Or — pass through unchanged
             other => other,
         }
     }
 
     // ─── Arity Normalization ─────────────────────────────────────
 
-    /// Fit an argument vector to a target arity: truncate if too long,
-    /// pad with Unspecified if too short. Ensures every predicate receives
-    /// exactly the right number of arguments regardless of calling context.
     fn fit_args(args: &[LogicalTerm], arity: usize) -> Vec<LogicalTerm> {
         let mut fitted = Vec::with_capacity(arity);
         for i in 0..arity {
@@ -196,9 +199,6 @@ impl SemanticCompiler {
 
     // ─── Selbri Application ──────────────────────────────────────
 
-    /// Recursively instantiates a Selbri against a set of arguments, correctly
-    /// mapping intersective Tanru, argument-swapping conversions, negation,
-    /// grouping, be/bei binding, and connectives across the AST tree.
     fn apply_selbri(
         &mut self,
         selbri_id: u32,
@@ -216,8 +216,6 @@ impl SemanticCompiler {
                 }
             }
 
-            // Tanru → Intersective Conjunction: sutra gerku(x) = sutra(x) ∧ gerku(x)
-            // Each sub-selbri gets args fit to its own arity.
             Selbri::Tanru((mod_id, head_id)) => {
                 let mod_arity = self.get_selbri_arity(*mod_id, selbris);
                 let head_arity = self.get_selbri_arity(*head_id, selbris);
@@ -238,7 +236,6 @@ impl SemanticCompiler {
                 LogicalForm::And(Box::new(left), Box::new(right))
             }
 
-            // SE-conversion: permute argument positions
             Selbri::Converted((conv, inner_id)) => {
                 let mut permuted = args.to_vec();
                 match conv {
@@ -251,31 +248,26 @@ impl SemanticCompiler {
                 self.apply_selbri(*inner_id, &permuted, selbris, sumtis, sentences)
             }
 
-            // FIX 1.2: Selbri negation → ¬P(args)
             Selbri::Negated(inner_id) => {
                 let inner = self.apply_selbri(*inner_id, args, selbris, sumtis, sentences);
                 LogicalForm::Not(Box::new(inner))
             }
 
-            // FIX 1.7: ke/ke'e grouping — transparent wrapper, just recurse
             Selbri::Grouped(inner_id) => {
                 self.apply_selbri(*inner_id, args, selbris, sumtis, sentences)
             }
 
-            // FIX 1.5: be/bei clause — bound arguments fill x2, x3, ... of the core
             Selbri::WithArgs((core_id, bound_ids)) => {
                 let core_arity = self.get_selbri_arity(*core_id, selbris);
                 let mut merged = Vec::with_capacity(core_arity);
                 let mut inner_quantifiers: Vec<QuantifierEntry> = Vec::new();
 
-                // x1 from outer context
                 merged.push(if !args.is_empty() {
                     args[0].clone()
                 } else {
                     LogicalTerm::Unspecified
                 });
 
-                // x2, x3, ... from be/bei bound arguments
                 for bound_id in bound_ids.iter() {
                     let bound_sumti = &sumtis[*bound_id as usize];
                     let (term, quants) =
@@ -284,8 +276,7 @@ impl SemanticCompiler {
                     merged.push(term);
                 }
 
-                // Pad remaining positions with outer args (if any) or Unspecified
-                let bound_count = 1 + bound_ids.len(); // x1 + be/bei args
+                let bound_count = 1 + bound_ids.len();
                 for i in merged.len()..core_arity {
                     if i < args.len() && i >= bound_count {
                         merged.push(args[i].clone());
@@ -296,7 +287,6 @@ impl SemanticCompiler {
 
                 let mut form = self.apply_selbri(*core_id, &merged, selbris, sumtis, sentences);
 
-                // Wrap with quantifiers from be/bei arguments (e.g., "nelci be lo gerku")
                 for entry in inner_quantifiers.into_iter().rev() {
                     let desc_arity = self.get_selbri_arity(entry.desc_id, selbris);
                     let mut restrictor_args = vec![LogicalTerm::Variable(entry.var)];
@@ -310,18 +300,33 @@ impl SemanticCompiler {
                         sumtis,
                         sentences,
                     );
-                    let mut body = LogicalForm::And(Box::new(restrictor), Box::new(form));
-                    if let Some(rel_restrictor) = entry.restrictor {
-                        body = LogicalForm::And(Box::new(rel_restrictor), Box::new(body));
+
+                    if entry.universal {
+                        // ∀x. (restrictor → body) = ∀x. (¬restrictor ∨ body)
+                        let mut body = LogicalForm::Or(
+                            Box::new(LogicalForm::Not(Box::new(restrictor))),
+                            Box::new(form),
+                        );
+                        if let Some(rel_restrictor) = entry.restrictor {
+                            body = LogicalForm::Or(
+                                Box::new(LogicalForm::Not(Box::new(rel_restrictor))),
+                                Box::new(body),
+                            );
+                        }
+                        form = LogicalForm::ForAll(entry.var, Box::new(body));
+                    } else {
+                        // ∃x. (restrictor ∧ body)
+                        let mut body = LogicalForm::And(Box::new(restrictor), Box::new(form));
+                        if let Some(rel_restrictor) = entry.restrictor {
+                            body = LogicalForm::And(Box::new(rel_restrictor), Box::new(body));
+                        }
+                        form = LogicalForm::Exists(entry.var, Box::new(body));
                     }
-                    form = LogicalForm::Exists(entry.var, Box::new(body));
                 }
 
                 form
             }
 
-            // FIX 1.6: Selbri connectives — je/ja/jo/ju
-            // Each side gets args fit to its own arity.
             Selbri::Connected((left_id, conn, right_id)) => {
                 let left_arity = self.get_selbri_arity(*left_id, selbris);
                 let right_arity = self.get_selbri_arity(*right_id, selbris);
@@ -331,13 +336,8 @@ impl SemanticCompiler {
                 let right = self.apply_selbri(*right_id, &right_args, selbris, sumtis, sentences);
 
                 match conn {
-                    // je (AND): P(x) ∧ Q(x)
                     Connective::Je => LogicalForm::And(Box::new(left), Box::new(right)),
-
-                    // ja (OR): P(x) ∨ Q(x)
                     Connective::Ja => LogicalForm::Or(Box::new(left), Box::new(right)),
-
-                    // jo (IFF): (¬A ∨ B) ∧ (¬B ∨ A)
                     Connective::Jo => {
                         let not_l = LogicalForm::Not(Box::new(left.clone()));
                         let not_r = LogicalForm::Not(Box::new(right.clone()));
@@ -346,8 +346,6 @@ impl SemanticCompiler {
                             Box::new(LogicalForm::Or(Box::new(not_r), Box::new(left))),
                         )
                     }
-
-                    // ju (XOR): (A ∨ B) ∧ ¬(A ∧ B)
                     Connective::Ju => LogicalForm::And(
                         Box::new(LogicalForm::Or(
                             Box::new(left.clone()),
@@ -383,8 +381,6 @@ impl SemanticCompiler {
     ) -> LogicalForm {
         let target_arity = self.get_selbri_arity(bridi.relation, selbris);
 
-        // FIX 1.3: Positional argument vector for place-tagged sumti.
-        // Tagged sumti go to their explicit position; untagged fill remaining slots.
         let mut positioned: Vec<Option<LogicalTerm>> = vec![None; target_arity];
         let mut untagged: Vec<LogicalTerm> = Vec::new();
         let mut quantifiers: Vec<QuantifierEntry> = Vec::new();
@@ -416,7 +412,6 @@ impl SemanticCompiler {
             }
         }
 
-        // Merge: tagged args at their positions, untagged fill remaining None slots
         let mut untagged_iter = untagged.into_iter();
         let args: Vec<LogicalTerm> = positioned
             .into_iter()
@@ -426,10 +421,9 @@ impl SemanticCompiler {
             })
             .collect();
 
-        // Construct the main relation via tree traversal
         let mut final_form = self.apply_selbri(bridi.relation, &args, selbris, sumtis, sentences);
 
-        // Wrap with existential quantifiers and restrictors (inner-to-outer)
+        // Wrap with quantifiers (inner-to-outer)
         for entry in quantifiers.into_iter().rev() {
             let desc_arity = self.get_selbri_arity(entry.desc_id, selbris);
 
@@ -439,20 +433,41 @@ impl SemanticCompiler {
                 restrictor_args.push(LogicalTerm::Unspecified);
             }
 
-            // Description selbris map structurally just like the main relation
             let desc_restrictor =
                 self.apply_selbri(entry.desc_id, &restrictor_args, selbris, sumtis, sentences);
-            let mut body = LogicalForm::And(Box::new(desc_restrictor), Box::new(final_form));
 
-            // Conjoin relative clause restrictor if present
-            if let Some(rel_restrictor) = entry.restrictor {
-                body = LogicalForm::And(Box::new(rel_restrictor), Box::new(body));
-            }
+            if entry.universal {
+                // ∀x. (restrictor → body) = ∀x. (¬restrictor ∨ body)
+                let mut body = LogicalForm::Or(
+                    Box::new(LogicalForm::Not(Box::new(desc_restrictor))),
+                    Box::new(final_form),
+                );
+
+                // Conjoin relative clause restrictor into antecedent if present
+                if let Some(rel_restrictor) = entry.restrictor {
+                    // ∀x. ((restrictor ∧ rel_clause) → body)
+                    // = ∀x. (¬(restrictor ∧ rel_clause) ∨ body)
+                    // = ∀x. (¬restrictor ∨ ¬rel_clause ∨ body)
+                    // But cleaner: just wrap the rel_clause into the antecedent
+                    body = LogicalForm::Or(
+                        Box::new(LogicalForm::Not(Box::new(rel_restrictor))),
+                        Box::new(body),
+                    );
+                }
+
+                final_form = LogicalForm::ForAll(entry.var, Box::new(body));
+            } else {
+                // ∃x. (restrictor ∧ body)
+                let mut body = LogicalForm::And(Box::new(desc_restrictor), Box::new(final_form));
 
-            final_form = LogicalForm::Exists(entry.var, Box::new(body));
+                if let Some(rel_restrictor) = entry.restrictor {
+                    body = LogicalForm::And(Box::new(rel_restrictor), Box::new(body));
+                }
+
+                final_form = LogicalForm::Exists(entry.var, Box::new(body));
+            }
         }
 
-        // FIX 1.1: Sentence-level negation
         if bridi.negated {
             final_form = LogicalForm::Not(Box::new(final_form));
         }
diff --git a/wit/world.wit b/wit/world.wit
index d5ec9a4..1c3d607 100644
--- a/wit/world.wit
+++ b/wit/world.wit
@@ -7,7 +7,7 @@ interface ast-types {
     enum place-tag { fa, fe, fi, fo, fu }
     enum conversion { se, te, ve, xe }
     enum connective { je, ja, jo, ju }
-    enum gadri { lo, le, la }
+    enum gadri { lo, le, la, ro-lo, ro-le }
     enum rel-clause-kind { poi, noi }
 
     record rel-clause {
@@ -108,3 +108,4 @@ world engine-pipeline {
     /// Debug: compile text to logic s-expression without asserting.
     export compile-debug: func(input: string) -> result<string, string>;
 }
+
