// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_execute_cabi<T: Guest>(arg0: *mut u8, arg1: usize) -> i32 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    let result1 = T::execute(_rt::string_lift(bytes0));
    match result1 {
        true => 1,
        false => 0,
    }
}
pub trait Guest {
    fn execute(input: _rt::String) -> bool;
}
#[doc(hidden)]
macro_rules! __export_world_engine_pipeline_cabi {
    ($ty:ident with_types_in $($path_to_types:tt)*) => {
        const _ : () = { #[unsafe (export_name = "execute")] unsafe extern "C" fn
        export_execute(arg0 : * mut u8, arg1 : usize,) -> i32 { unsafe {
        $($path_to_types)*:: _export_execute_cabi::<$ty > (arg0, arg1) } } };
    };
}
#[doc(hidden)]
pub(crate) use __export_world_engine_pipeline_cabi;
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod lojban {
    pub mod nesy {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod ast_types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type SelbriId = u32;
            pub type SumtiId = u32;
            /// ─── Grammatical marker enums ────────────────────────────────
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum PlaceTag {
                Fa,
                /// x1
                Fe,
                /// x2
                Fi,
                /// x3
                Fo,
                /// x4
                Fu,
            }
            impl ::core::fmt::Debug for PlaceTag {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        PlaceTag::Fa => f.debug_tuple("PlaceTag::Fa").finish(),
                        PlaceTag::Fe => f.debug_tuple("PlaceTag::Fe").finish(),
                        PlaceTag::Fi => f.debug_tuple("PlaceTag::Fi").finish(),
                        PlaceTag::Fo => f.debug_tuple("PlaceTag::Fo").finish(),
                        PlaceTag::Fu => f.debug_tuple("PlaceTag::Fu").finish(),
                    }
                }
            }
            impl PlaceTag {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> PlaceTag {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => PlaceTag::Fa,
                        1 => PlaceTag::Fe,
                        2 => PlaceTag::Fi,
                        3 => PlaceTag::Fo,
                        4 => PlaceTag::Fu,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum Conversion {
                Se,
                /// x1 ↔ x2
                Te,
                /// x1 ↔ x3
                Ve,
                /// x1 ↔ x4
                Xe,
            }
            impl ::core::fmt::Debug for Conversion {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Conversion::Se => f.debug_tuple("Conversion::Se").finish(),
                        Conversion::Te => f.debug_tuple("Conversion::Te").finish(),
                        Conversion::Ve => f.debug_tuple("Conversion::Ve").finish(),
                        Conversion::Xe => f.debug_tuple("Conversion::Xe").finish(),
                    }
                }
            }
            impl Conversion {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> Conversion {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => Conversion::Se,
                        1 => Conversion::Te,
                        2 => Conversion::Ve,
                        3 => Conversion::Xe,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum Connective {
                Je,
                /// AND (∧)
                Ja,
                /// OR  (∨)
                Jo,
                /// IFF (↔)
                Ju,
            }
            impl ::core::fmt::Debug for Connective {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Connective::Je => f.debug_tuple("Connective::Je").finish(),
                        Connective::Ja => f.debug_tuple("Connective::Ja").finish(),
                        Connective::Jo => f.debug_tuple("Connective::Jo").finish(),
                        Connective::Ju => f.debug_tuple("Connective::Ju").finish(),
                    }
                }
            }
            impl Connective {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> Connective {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => Connective::Je,
                        1 => Connective::Ja,
                        2 => Connective::Jo,
                        3 => Connective::Ju,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum Gadri {
                Lo,
                /// veridical (∃)
                Le,
                /// non-veridical
                La,
            }
            impl ::core::fmt::Debug for Gadri {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Gadri::Lo => f.debug_tuple("Gadri::Lo").finish(),
                        Gadri::Le => f.debug_tuple("Gadri::Le").finish(),
                        Gadri::La => f.debug_tuple("Gadri::La").finish(),
                    }
                }
            }
            impl Gadri {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> Gadri {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => Gadri::Lo,
                        1 => Gadri::Le,
                        2 => Gadri::La,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum RelClauseKind {
                Poi,
                /// restrictive
                Noi,
            }
            impl ::core::fmt::Debug for RelClauseKind {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        RelClauseKind::Poi => {
                            f.debug_tuple("RelClauseKind::Poi").finish()
                        }
                        RelClauseKind::Noi => {
                            f.debug_tuple("RelClauseKind::Noi").finish()
                        }
                    }
                }
            }
            impl RelClauseKind {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> RelClauseKind {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => RelClauseKind::Poi,
                        1 => RelClauseKind::Noi,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// ─── Sumti (arguments) ───────────────────────────────────────
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct RelClause {
                pub kind: RelClauseKind,
                pub body_sentence: u32,
            }
            impl ::core::fmt::Debug for RelClause {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("RelClause")
                        .field("kind", &self.kind)
                        .field("body-sentence", &self.body_sentence)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub enum Sumti {
                ProSumti(_rt::String),
                Description((Gadri, SelbriId)),
                Name(_rt::String),
                QuotedLiteral(_rt::String),
                Unspecified,
                Tagged((PlaceTag, SumtiId)),
                Restricted((SumtiId, RelClause)),
            }
            impl ::core::fmt::Debug for Sumti {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Sumti::ProSumti(e) => {
                            f.debug_tuple("Sumti::ProSumti").field(e).finish()
                        }
                        Sumti::Description(e) => {
                            f.debug_tuple("Sumti::Description").field(e).finish()
                        }
                        Sumti::Name(e) => f.debug_tuple("Sumti::Name").field(e).finish(),
                        Sumti::QuotedLiteral(e) => {
                            f.debug_tuple("Sumti::QuotedLiteral").field(e).finish()
                        }
                        Sumti::Unspecified => {
                            f.debug_tuple("Sumti::Unspecified").finish()
                        }
                        Sumti::Tagged(e) => {
                            f.debug_tuple("Sumti::Tagged").field(e).finish()
                        }
                        Sumti::Restricted(e) => {
                            f.debug_tuple("Sumti::Restricted").field(e).finish()
                        }
                    }
                }
            }
            /// ─── Selbri (predicates) ─────────────────────────────────────
            #[derive(Clone)]
            pub enum Selbri {
                Root(_rt::String),
                Compound(_rt::Vec<_rt::String>),
                Tanru((SelbriId, SelbriId)),
                Converted((Conversion, SelbriId)),
                Negated(SelbriId),
                Grouped(SelbriId),
                WithArgs((SelbriId, _rt::Vec<SumtiId>)),
                Connected((SelbriId, Connective, SelbriId)),
            }
            impl ::core::fmt::Debug for Selbri {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Selbri::Root(e) => {
                            f.debug_tuple("Selbri::Root").field(e).finish()
                        }
                        Selbri::Compound(e) => {
                            f.debug_tuple("Selbri::Compound").field(e).finish()
                        }
                        Selbri::Tanru(e) => {
                            f.debug_tuple("Selbri::Tanru").field(e).finish()
                        }
                        Selbri::Converted(e) => {
                            f.debug_tuple("Selbri::Converted").field(e).finish()
                        }
                        Selbri::Negated(e) => {
                            f.debug_tuple("Selbri::Negated").field(e).finish()
                        }
                        Selbri::Grouped(e) => {
                            f.debug_tuple("Selbri::Grouped").field(e).finish()
                        }
                        Selbri::WithArgs(e) => {
                            f.debug_tuple("Selbri::WithArgs").field(e).finish()
                        }
                        Selbri::Connected(e) => {
                            f.debug_tuple("Selbri::Connected").field(e).finish()
                        }
                    }
                }
            }
            /// ─── Bridi (predications) ────────────────────────────────────
            #[derive(Clone)]
            pub struct Bridi {
                pub relation: SelbriId,
                pub head_terms: _rt::Vec<SumtiId>,
                pub tail_terms: _rt::Vec<SumtiId>,
                pub negated: bool,
            }
            impl ::core::fmt::Debug for Bridi {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Bridi")
                        .field("relation", &self.relation)
                        .field("head-terms", &self.head_terms)
                        .field("tail-terms", &self.tail_terms)
                        .field("negated", &self.negated)
                        .finish()
                }
            }
            /// ─── Top-level buffer ────────────────────────────────────────
            #[derive(Clone)]
            pub struct AstBuffer {
                pub selbris: _rt::Vec<Selbri>,
                pub sumtis: _rt::Vec<Sumti>,
                pub sentences: _rt::Vec<Bridi>,
            }
            impl ::core::fmt::Debug for AstBuffer {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("AstBuffer")
                        .field("selbris", &self.selbris)
                        .field("sumtis", &self.sumtis)
                        .field("sentences", &self.sentences)
                        .finish()
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod parser {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type AstBuffer = super::super::super::lojban::nesy::ast_types::AstBuffer;
            #[allow(unused_unsafe, clippy::all)]
            pub fn parse_text(input: &str) -> Result<AstBuffer, _rt::String> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 7 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 7
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = input;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "lojban:nesy/parser@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "parse-text"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result66 = match l3 {
                        0 => {
                            let e = {
                                let l4 = *ptr1
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l5 = *ptr1
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base30 = l4;
                                let len30 = l5;
                                let mut result30 = _rt::Vec::with_capacity(len30);
                                for i in 0..len30 {
                                    let base = base30
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    let e30 = {
                                        let l6 = i32::from(*base.add(0).cast::<u8>());
                                        use super::super::super::lojban::nesy::ast_types::Selbri as V29;
                                        let v29 = match l6 {
                                            0 => {
                                                let e29 = {
                                                    let l7 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l8 = *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len9 = l8;
                                                    let bytes9 = _rt::Vec::from_raw_parts(
                                                        l7.cast(),
                                                        len9,
                                                        len9,
                                                    );
                                                    _rt::string_lift(bytes9)
                                                };
                                                V29::Root(e29)
                                            }
                                            1 => {
                                                let e29 = {
                                                    let l10 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l11 = *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let base15 = l10;
                                                    let len15 = l11;
                                                    let mut result15 = _rt::Vec::with_capacity(len15);
                                                    for i in 0..len15 {
                                                        let base = base15
                                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                                        let e15 = {
                                                            let l12 = *base.add(0).cast::<*mut u8>();
                                                            let l13 = *base
                                                                .add(::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len14 = l13;
                                                            let bytes14 = _rt::Vec::from_raw_parts(
                                                                l12.cast(),
                                                                len14,
                                                                len14,
                                                            );
                                                            _rt::string_lift(bytes14)
                                                        };
                                                        result15.push(e15);
                                                    }
                                                    _rt::cabi_dealloc(
                                                        base15,
                                                        len15 * (2 * ::core::mem::size_of::<*const u8>()),
                                                        ::core::mem::size_of::<*const u8>(),
                                                    );
                                                    result15
                                                };
                                                V29::Compound(e29)
                                            }
                                            2 => {
                                                let e29 = {
                                                    let l16 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    let l17 = *base
                                                        .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    (l16 as u32, l17 as u32)
                                                };
                                                V29::Tanru(e29)
                                            }
                                            3 => {
                                                let e29 = {
                                                    let l18 = i32::from(
                                                        *base.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                                    );
                                                    let l19 = *base
                                                        .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    (
                                                        super::super::super::lojban::nesy::ast_types::Conversion::_lift(
                                                            l18 as u8,
                                                        ),
                                                        l19 as u32,
                                                    )
                                                };
                                                V29::Converted(e29)
                                            }
                                            4 => {
                                                let e29 = {
                                                    let l20 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    l20 as u32
                                                };
                                                V29::Negated(e29)
                                            }
                                            5 => {
                                                let e29 = {
                                                    let l21 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    l21 as u32
                                                };
                                                V29::Grouped(e29)
                                            }
                                            6 => {
                                                let e29 = {
                                                    let l22 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    let l23 = *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l24 = *base
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len25 = l24;
                                                    (
                                                        l22 as u32,
                                                        _rt::Vec::from_raw_parts(l23.cast(), len25, len25),
                                                    )
                                                };
                                                V29::WithArgs(e29)
                                            }
                                            n => {
                                                debug_assert_eq!(n, 7, "invalid enum discriminant");
                                                let e29 = {
                                                    let l26 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    let l27 = i32::from(
                                                        *base
                                                            .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l28 = *base
                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    (
                                                        l26 as u32,
                                                        super::super::super::lojban::nesy::ast_types::Connective::_lift(
                                                            l27 as u8,
                                                        ),
                                                        l28 as u32,
                                                    )
                                                };
                                                V29::Connected(e29)
                                            }
                                        };
                                        v29
                                    };
                                    result30.push(e30);
                                }
                                _rt::cabi_dealloc(
                                    base30,
                                    len30 * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                let l31 = *ptr1
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l32 = *ptr1
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base51 = l31;
                                let len51 = l32;
                                let mut result51 = _rt::Vec::with_capacity(len51);
                                for i in 0..len51 {
                                    let base = base51
                                        .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                    let e51 = {
                                        let l33 = i32::from(*base.add(0).cast::<u8>());
                                        use super::super::super::lojban::nesy::ast_types::Sumti as V50;
                                        let v50 = match l33 {
                                            0 => {
                                                let e50 = {
                                                    let l34 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l35 = *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len36 = l35;
                                                    let bytes36 = _rt::Vec::from_raw_parts(
                                                        l34.cast(),
                                                        len36,
                                                        len36,
                                                    );
                                                    _rt::string_lift(bytes36)
                                                };
                                                V50::ProSumti(e50)
                                            }
                                            1 => {
                                                let e50 = {
                                                    let l37 = i32::from(
                                                        *base.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                                    );
                                                    let l38 = *base
                                                        .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    (
                                                        super::super::super::lojban::nesy::ast_types::Gadri::_lift(
                                                            l37 as u8,
                                                        ),
                                                        l38 as u32,
                                                    )
                                                };
                                                V50::Description(e50)
                                            }
                                            2 => {
                                                let e50 = {
                                                    let l39 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l40 = *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len41 = l40;
                                                    let bytes41 = _rt::Vec::from_raw_parts(
                                                        l39.cast(),
                                                        len41,
                                                        len41,
                                                    );
                                                    _rt::string_lift(bytes41)
                                                };
                                                V50::Name(e50)
                                            }
                                            3 => {
                                                let e50 = {
                                                    let l42 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l43 = *base
                                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len44 = l43;
                                                    let bytes44 = _rt::Vec::from_raw_parts(
                                                        l42.cast(),
                                                        len44,
                                                        len44,
                                                    );
                                                    _rt::string_lift(bytes44)
                                                };
                                                V50::QuotedLiteral(e50)
                                            }
                                            4 => V50::Unspecified,
                                            5 => {
                                                let e50 = {
                                                    let l45 = i32::from(
                                                        *base.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                                    );
                                                    let l46 = *base
                                                        .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    (
                                                        super::super::super::lojban::nesy::ast_types::PlaceTag::_lift(
                                                            l45 as u8,
                                                        ),
                                                        l46 as u32,
                                                    )
                                                };
                                                V50::Tagged(e50)
                                            }
                                            n => {
                                                debug_assert_eq!(n, 6, "invalid enum discriminant");
                                                let e50 = {
                                                    let l47 = *base
                                                        .add(::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    let l48 = i32::from(
                                                        *base
                                                            .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l49 = *base
                                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    (
                                                        l47 as u32,
                                                        super::super::super::lojban::nesy::ast_types::RelClause {
                                                            kind: super::super::super::lojban::nesy::ast_types::RelClauseKind::_lift(
                                                                l48 as u8,
                                                            ),
                                                            body_sentence: l49 as u32,
                                                        },
                                                    )
                                                };
                                                V50::Restricted(e50)
                                            }
                                        };
                                        v50
                                    };
                                    result51.push(e51);
                                }
                                _rt::cabi_dealloc(
                                    base51,
                                    len51 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                let l52 = *ptr1
                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l53 = *ptr1
                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base62 = l52;
                                let len62 = l53;
                                let mut result62 = _rt::Vec::with_capacity(len62);
                                for i in 0..len62 {
                                    let base = base62
                                        .add(i * (6 * ::core::mem::size_of::<*const u8>()));
                                    let e62 = {
                                        let l54 = *base.add(0).cast::<i32>();
                                        let l55 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l56 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len57 = l56;
                                        let l58 = *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l59 = *base
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len60 = l59;
                                        let l61 = i32::from(
                                            *base
                                                .add(5 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>(),
                                        );
                                        super::super::super::lojban::nesy::ast_types::Bridi {
                                            relation: l54 as u32,
                                            head_terms: _rt::Vec::from_raw_parts(
                                                l55.cast(),
                                                len57,
                                                len57,
                                            ),
                                            tail_terms: _rt::Vec::from_raw_parts(
                                                l58.cast(),
                                                len60,
                                                len60,
                                            ),
                                            negated: _rt::bool_lift(l61 as u8),
                                        }
                                    };
                                    result62.push(e62);
                                }
                                _rt::cabi_dealloc(
                                    base62,
                                    len62 * (6 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                super::super::super::lojban::nesy::ast_types::AstBuffer {
                                    selbris: result30,
                                    sumtis: result51,
                                    sentences: result62,
                                }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l63 = *ptr1
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l64 = *ptr1
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len65 = l64;
                                let bytes65 = _rt::Vec::from_raw_parts(
                                    l63.cast(),
                                    len65,
                                    len65,
                                );
                                _rt::string_lift(bytes65)
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result66
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod semantics {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type AstBuffer = super::super::super::lojban::nesy::ast_types::AstBuffer;
            #[allow(unused_unsafe, clippy::all)]
            pub fn compile_buffer(
                ast: &AstBuffer,
            ) -> Result<_rt::Vec<_rt::String>, _rt::String> {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 3 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 3
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let super::super::super::lojban::nesy::ast_types::AstBuffer {
                        selbris: selbris0,
                        sumtis: sumtis0,
                        sentences: sentences0,
                    } = ast;
                    let vec10 = selbris0;
                    let len10 = vec10.len();
                    let layout10 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec10.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result10 = if layout10.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout10).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout10);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec10.into_iter().enumerate() {
                        let base = result10
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            use super::super::super::lojban::nesy::ast_types::Selbri as V9;
                            match e {
                                V9::Root(e) => {
                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                    let vec1 = e;
                                    let ptr1 = vec1.as_ptr().cast::<u8>();
                                    let len1 = vec1.len();
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len1;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr1.cast_mut();
                                }
                                V9::Compound(e) => {
                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                    let vec3 = e;
                                    let len3 = vec3.len();
                                    let layout3 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec3.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result3 = if layout3.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout3);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec3.into_iter().enumerate() {
                                        let base = result3
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec2 = e;
                                            let ptr2 = vec2.as_ptr().cast::<u8>();
                                            let len2 = vec2.len();
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len2;
                                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                                        }
                                    }
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result3;
                                    cleanup_list.extend_from_slice(&[(result3, layout3)]);
                                }
                                V9::Tanru(e) => {
                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                    let (t4_0, t4_1) = e;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(t4_0);
                                    *base
                                        .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(t4_1);
                                }
                                V9::Converted(e) => {
                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                    let (t5_0, t5_1) = e;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (t5_0.clone() as i32) as u8;
                                    *base
                                        .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(t5_1);
                                }
                                V9::Negated(e) => {
                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(e);
                                }
                                V9::Grouped(e) => {
                                    *base.add(0).cast::<u8>() = (5i32) as u8;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(e);
                                }
                                V9::WithArgs(e) => {
                                    *base.add(0).cast::<u8>() = (6i32) as u8;
                                    let (t6_0, t6_1) = e;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(t6_0);
                                    let vec7 = t6_1;
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V9::Connected(e) => {
                                    *base.add(0).cast::<u8>() = (7i32) as u8;
                                    let (t8_0, t8_1, t8_2) = e;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(t8_0);
                                    *base
                                        .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (t8_1.clone() as i32) as u8;
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(t8_2);
                                }
                            }
                        }
                    }
                    let vec19 = sumtis0;
                    let len19 = vec19.len();
                    let layout19 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec19.len() * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result19 = if layout19.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout19).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout19);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec19.into_iter().enumerate() {
                        let base = result19
                            .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                        {
                            use super::super::super::lojban::nesy::ast_types::Sumti as V18;
                            match e {
                                V18::ProSumti(e) => {
                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                    let vec11 = e;
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V18::Description(e) => {
                                    *base.add(0).cast::<u8>() = (1i32) as u8;
                                    let (t12_0, t12_1) = e;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (t12_0.clone() as i32) as u8;
                                    *base
                                        .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(t12_1);
                                }
                                V18::Name(e) => {
                                    *base.add(0).cast::<u8>() = (2i32) as u8;
                                    let vec13 = e;
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V18::QuotedLiteral(e) => {
                                    *base.add(0).cast::<u8>() = (3i32) as u8;
                                    let vec14 = e;
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V18::Unspecified => {
                                    *base.add(0).cast::<u8>() = (4i32) as u8;
                                }
                                V18::Tagged(e) => {
                                    *base.add(0).cast::<u8>() = (5i32) as u8;
                                    let (t15_0, t15_1) = e;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (t15_0.clone() as i32) as u8;
                                    *base
                                        .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(t15_1);
                                }
                                V18::Restricted(e) => {
                                    *base.add(0).cast::<u8>() = (6i32) as u8;
                                    let (t16_0, t16_1) = e;
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(t16_0);
                                    let super::super::super::lojban::nesy::ast_types::RelClause {
                                        kind: kind17,
                                        body_sentence: body_sentence17,
                                    } = t16_1;
                                    *base
                                        .add(4 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (kind17.clone() as i32) as u8;
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(body_sentence17);
                                }
                            }
                        }
                    }
                    let vec23 = sentences0;
                    let len23 = vec23.len();
                    let layout23 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec23.len() * (6 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result23 = if layout23.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout23).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout23);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec23.into_iter().enumerate() {
                        let base = result23
                            .add(i * (6 * ::core::mem::size_of::<*const u8>()));
                        {
                            let super::super::super::lojban::nesy::ast_types::Bridi {
                                relation: relation20,
                                head_terms: head_terms20,
                                tail_terms: tail_terms20,
                                negated: negated20,
                            } = e;
                            *base.add(0).cast::<i32>() = _rt::as_i32(relation20);
                            let vec21 = head_terms20;
                            let ptr21 = vec21.as_ptr().cast::<u8>();
                            let len21 = vec21.len();
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len21;
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr21.cast_mut();
                            let vec22 = tail_terms20;
                            let ptr22 = vec22.as_ptr().cast::<u8>();
                            let len22 = vec22.len();
                            *base
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len22;
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr22.cast_mut();
                            *base
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (match negated20 {
                                true => 1,
                                false => 0,
                            }) as u8;
                        }
                    }
                    let ptr24 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "lojban:nesy/semantics@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "compile-buffer"]
                        fn wit_import25(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import25(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import25(
                            result10,
                            len10,
                            result19,
                            len19,
                            result23,
                            len23,
                            ptr24,
                        )
                    };
                    let l26 = i32::from(*ptr24.add(0).cast::<u8>());
                    let result36 = match l26 {
                        0 => {
                            let e = {
                                let l27 = *ptr24
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l28 = *ptr24
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base32 = l27;
                                let len32 = l28;
                                let mut result32 = _rt::Vec::with_capacity(len32);
                                for i in 0..len32 {
                                    let base = base32
                                        .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                    let e32 = {
                                        let l29 = *base.add(0).cast::<*mut u8>();
                                        let l30 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len31 = l30;
                                        let bytes31 = _rt::Vec::from_raw_parts(
                                            l29.cast(),
                                            len31,
                                            len31,
                                        );
                                        _rt::string_lift(bytes31)
                                    };
                                    result32.push(e32);
                                }
                                _rt::cabi_dealloc(
                                    base32,
                                    len32 * (2 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                result32
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l33 = *ptr24
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l34 = *ptr24
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len35 = l34;
                                let bytes35 = _rt::Vec::from_raw_parts(
                                    l33.cast(),
                                    len35,
                                    len35,
                                );
                                _rt::string_lift(bytes35)
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    if layout10.size() != 0 {
                        _rt::alloc::dealloc(result10.cast(), layout10);
                    }
                    if layout19.size() != 0 {
                        _rt::alloc::dealloc(result19.cast(), layout19);
                    }
                    if layout23.size() != 0 {
                        _rt::alloc::dealloc(result23.cast(), layout23);
                    }
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                    result36
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod reasoning {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            pub fn assert_fact(sexp: &str) -> Result<(), _rt::String> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 3 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 3
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = sexp;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "lojban:nesy/reasoning@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "assert-fact"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result7 = match l3 {
                        0 => {
                            let e = ();
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l4 = *ptr1
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l5 = *ptr1
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len6 = l5;
                                let bytes6 = _rt::Vec::from_raw_parts(
                                    l4.cast(),
                                    len6,
                                    len6,
                                );
                                _rt::string_lift(bytes6)
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result7
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn query_entailment(sexp: &str) -> Result<bool, _rt::String> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 3 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 3
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = sexp;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "lojban:nesy/reasoning@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "query-entailment"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    let result8 = match l3 {
                        0 => {
                            let e = {
                                let l4 = i32::from(
                                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                );
                                _rt::bool_lift(l4 as u8)
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l5 = *ptr1
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l6 = *ptr1
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len7 = l6;
                                let bytes7 = _rt::Vec::from_raw_parts(
                                    l5.cast(),
                                    len7,
                                    len7,
                                );
                                _rt::string_lift(bytes7)
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    result8
                }
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub use alloc_crate::alloc;
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_engine_pipeline_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*:: __export_world_engine_pipeline_cabi!($ty with_types_in
        $($path_to_types_root)*);
    };
}
#[doc(inline)]
pub(crate) use __export_engine_pipeline_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:lojban:nesy@0.1.0:engine-pipeline:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1126] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xe0\x07\x01A\x02\x01\
A\x0b\x01B$\x01y\x04\0\x09selbri-id\x03\0\0\x01y\x04\0\x08sumti-id\x03\0\x02\x01\
m\x05\x02fa\x02fe\x02fi\x02fo\x02fu\x04\0\x09place-tag\x03\0\x04\x01m\x04\x02se\x02\
te\x02ve\x02xe\x04\0\x0aconversion\x03\0\x06\x01m\x04\x02je\x02ja\x02jo\x02ju\x04\
\0\x0aconnective\x03\0\x08\x01m\x03\x02lo\x02le\x02la\x04\0\x05gadri\x03\0\x0a\x01\
m\x02\x03poi\x03noi\x04\0\x0frel-clause-kind\x03\0\x0c\x01r\x02\x04kind\x0d\x0db\
ody-sentencey\x04\0\x0arel-clause\x03\0\x0e\x01o\x02\x0b\x01\x01o\x02\x05\x03\x01\
o\x02\x03\x0f\x01q\x07\x09pro-sumti\x01s\0\x0bdescription\x01\x10\0\x04name\x01s\
\0\x0equoted-literal\x01s\0\x0bunspecified\0\0\x06tagged\x01\x11\0\x0arestricted\
\x01\x12\0\x04\0\x05sumti\x03\0\x13\x01ps\x01o\x02\x01\x01\x01o\x02\x07\x01\x01p\
\x03\x01o\x02\x01\x18\x01o\x03\x01\x09\x01\x01q\x08\x04root\x01s\0\x08compound\x01\
\x15\0\x05tanru\x01\x16\0\x09converted\x01\x17\0\x07negated\x01\x01\0\x07grouped\
\x01\x01\0\x09with-args\x01\x19\0\x09connected\x01\x1a\0\x04\0\x06selbri\x03\0\x1b\
\x01r\x04\x08relation\x01\x0ahead-terms\x18\x0atail-terms\x18\x07negated\x7f\x04\
\0\x05bridi\x03\0\x1d\x01p\x1c\x01p\x14\x01p\x1e\x01r\x03\x07selbris\x1f\x06sumt\
is\x20\x09sentences!\x04\0\x0aast-buffer\x03\0\"\x03\0\x1blojban:nesy/ast-types@\
0.1.0\x05\0\x02\x03\0\0\x0aast-buffer\x01B\x05\x02\x03\x02\x01\x01\x04\0\x0aast-\
buffer\x03\0\0\x01j\x01\x01\x01s\x01@\x01\x05inputs\0\x02\x04\0\x0aparse-text\x01\
\x03\x03\0\x18lojban:nesy/parser@0.1.0\x05\x02\x01B\x06\x02\x03\x02\x01\x01\x04\0\
\x0aast-buffer\x03\0\0\x01ps\x01j\x01\x02\x01s\x01@\x01\x03ast\x01\0\x03\x04\0\x0e\
compile-buffer\x01\x04\x03\0\x1blojban:nesy/semantics@0.1.0\x05\x03\x01B\x06\x01\
j\0\x01s\x01@\x01\x04sexps\0\0\x04\0\x0bassert-fact\x01\x01\x01j\x01\x7f\x01s\x01\
@\x01\x04sexps\0\x02\x04\0\x10query-entailment\x01\x03\x03\0\x1blojban:nesy/reas\
oning@0.1.0\x05\x04\x01@\x01\x05inputs\0\x7f\x04\0\x07execute\x01\x05\x04\0!lojb\
an:nesy/engine-pipeline@0.1.0\x04\0\x0b\x15\x01\0\x0fengine-pipeline\x03\0\0\0G\x09\
producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rus\
t\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
