package lojban:nesy@0.1.0;

interface ast-types {
    type selbri-id = u32;
    type sumti-id = u32;

    enum place-tag { fa, fe, fi, fo, fu }
    enum bai-tag { ria, nii, mui, kiu, pio, bai }
    variant modal-tag {
        fixed(bai-tag),
        fio(selbri-id),
    }
    enum conversion { se, te, ve, xe }
    enum connective { je, ja, jo, ju }
    enum gadri { lo, le, la, ro-lo, ro-le }
    enum abstraction-kind { nu, duhu, ka, ni, siho }
    enum rel-clause-kind { poi, noi, voi }

    record rel-clause {
        kind: rel-clause-kind,
        body-sentence: u32,
    }

    variant sumti {
        pro-sumti(string),
        description(tuple<gadri, selbri-id>),
        name(string),
        quoted-literal(string),
        unspecified,
        tagged(tuple<place-tag, sumti-id>),
        modal-tagged(tuple<modal-tag, sumti-id>),
        restricted(tuple<sumti-id, rel-clause>),
        number(f64),
        /// Sumti connective: left .e/.a/.o/.u [nai] right
        /// Fields: (left-sumti-id, connective, right-negated, right-sumti-id)
        connected(tuple<sumti-id, connective, bool, sumti-id>),
        /// Numeric quantifier + description: PA lo/le selbri [ku]
        /// Fields: (count, gadri, selbri-id)
        quantified-description(tuple<u32, gadri, selbri-id>),
    }

    variant selbri {
        root(string),
        compound(list<string>),
        tanru(tuple<selbri-id, selbri-id>),
        converted(tuple<conversion, selbri-id>),
        negated(selbri-id),
        grouped(selbri-id),
        with-args(tuple<selbri-id, list<sumti-id>>),
        connected(tuple<selbri-id, connective, selbri-id>),
        /// Abstraction: inner bridi lives in sentences[u32].
        /// Arity is 1 (x1 = reified entity: event/proposition/property/quantity/concept).
        abstraction(tuple<abstraction-kind, u32>),
    }

    enum tense { pu, ca, ba }

    enum attitudinal { ei, ehe }

    record bridi {
        relation: selbri-id,
        head-terms: list<sumti-id>,
        tail-terms: list<sumti-id>,
        negated: bool,
        tense: option<tense>,
        attitudinal: option<attitudinal>,
    }

    variant sentence-connective {
        ganai-gi,
        ge-gi,
        ga-gi,
        /// Afterthought: .i [na] (je|ja|jo|ju) [nai]
        /// Fields: (left-negated, connective, right-negated)
        afterthought(tuple<bool, connective, bool>),
    }

    variant sentence {
        simple(bridi),
        connected(tuple<sentence-connective, u32, u32>), // Pointers to other sentences
    }

    record ast-buffer {
        selbris: list<selbri>,
        sumtis: list<sumti>,
        sentences: list<sentence>,
        roots: list<u32>,
    }

    record parse-error {
        message: string,
        line: u32,
        column: u32,
    }

    record parse-result {
        buffer: ast-buffer,
        errors: list<parse-error>,
    }
}

interface error-types {
    /// Structured error type for the Nibli engine pipeline.
    variant nibli-error {
        /// Parse error with source location.
        syntax(syntax-detail),
        /// Semantic compilation error.
        semantic(string),
        /// Reasoning engine error (egglog assertion/query failure).
        reasoning(string),
        /// Compute backend error. Fields: (kind, message).
        backend(tuple<string, string>),
    }

    record syntax-detail {
        message: string,
        line: u32,
        column: u32,
    }
}

interface logic-types {
    variant logical-term {
        variable(string),
        constant(string),
        description(string),
        unspecified,
        number(f64),
    }

    variant logic-node {
        predicate(tuple<string, list<logical-term>>),
        /// A predicate dispatched to an external compute backend for evaluation.
        compute-node(tuple<string, list<logical-term>>),
        and-node(tuple<u32, u32>),
        or-node(tuple<u32, u32>),
        not-node(u32),
        exists-node(tuple<string, u32>),
        for-all-node(tuple<string, u32>),
        past-node(u32),
        present-node(u32),
        future-node(u32),
        obligatory-node(u32),
        permitted-node(u32),
        /// Exactly N entities satisfy the body: Count(variable-name, count, body-node-id)
        count-node(tuple<string, u32, u32>),
    }

    record logic-buffer {
        nodes: list<logic-node>,
        roots: list<u32>,
    }

    /// A single variable-to-term binding from witness extraction.
    record witness-binding {
        variable: string,
        term: logical-term,
    }

    /// Proof rule applied at a proof step.
    variant proof-rule {
        /// Both conjuncts checked. Children: [left, right].
        conjunction,
        /// Entire disjunction found in e-graph. Payload: sexp checked.
        disjunction-egraph(string),
        /// One disjunct checked. Payload: "left" or "right". Children: [winner].
        disjunction-intro(string),
        /// Inner formula failed. Children: [inner-attempt].
        negation,
        /// Transparent tense/deontic wrapper. Payload: wrapper kind. Children: [inner].
        modal-passthrough(string),
        /// Entity witness found. Payload: (variable, witness-term). Children: [body-proof].
        exists-witness(tuple<string, logical-term>),
        /// No witness found for existential.
        exists-failed,
        /// Empty domain, vacuously true.
        forall-vacuous,
        /// All entities verified. Payload: entity list. Children: [body-proof per entity].
        forall-verified(list<logical-term>),
        /// Counterexample found. Payload: failing entity. Children: [failed-body-proof].
        forall-counterexample(logical-term),
        /// Count check. Payload: (expected, actual).
        count-result(tuple<u32, u32>),
        /// Predicate leaf checked. Payload: (method, sexp-or-detail).
        predicate-check(tuple<string, string>),
        /// Compute node checked. Payload: (method, relation-or-detail).
        compute-check(tuple<string, string>),
        /// Directly asserted fact (ground truth). Payload: sexp that was asserted.
        asserted(string),
        /// Derived via universal rule saturation. Payload: (rule-label, conclusion-sexp).
        /// Children: proof traces of each premise that triggered the rule.
        derived(tuple<string, string>),
    }

    /// A single step in a proof trace.
    record proof-step {
        rule: proof-rule,
        holds: bool,
        children: list<u32>,
    }

    /// A complete proof trace (flat indexed buffer).
    record proof-trace {
        steps: list<proof-step>,
        root: u32,
    }
}

interface parser {
    use ast-types.{parse-result};
    use error-types.{nibli-error};
    parse-text: func(input: string) -> result<parse-result, nibli-error>;
}

interface semantics {
    use ast-types.{ast-buffer};
    use logic-types.{logic-buffer};
    use error-types.{nibli-error};
    compile-buffer: func(ast: ast-buffer) -> result<logic-buffer, nibli-error>;
}

interface compute-backend {
    use logic-types.{logical-term};
    use error-types.{nibli-error};
    /// Evaluate whether a computed predicate holds for fully-ground arguments.
    evaluate: func(relation: string, args: list<logical-term>) -> result<bool, nibli-error>;
}

interface reasoning {
    use logic-types.{logic-buffer, witness-binding, proof-trace};
    use error-types.{nibli-error};

    resource knowledge-base {
        /// Create a fresh KB with FOL schema loaded.
        constructor();
        /// Assert FOL facts into this KB.
        assert-fact: func(logic: logic-buffer) -> result<_, nibli-error>;
        /// Query whether FOL formula is entailed by this KB.
        query-entailment: func(logic: logic-buffer) -> result<bool, nibli-error>;
        /// Query with proof trace: returns result + proof tree.
        query-entailment-with-proof: func(logic: logic-buffer) -> result<tuple<bool, proof-trace>, nibli-error>;
        /// Query with witness extraction: returns all satisfying binding sets
        /// for existential variables. Each inner list is one complete assignment.
        query-find: func(logic: logic-buffer) -> result<list<list<witness-binding>>, nibli-error>;
        /// Reset this KB to fresh state (clear all facts, Skolems, rules).
        reset: func() -> result<_, nibli-error>;
    }
}

// --- Component Worlds ---
world parser-component { export parser; }
world semantics-component { export semantics; }
world reasoning-component {
    import compute-backend;
    export reasoning;
}

interface engine {
    use logic-types.{logical-term, witness-binding, proof-trace};
    use error-types.{nibli-error};

    resource session {
        /// Create a new session (internally creates a fresh KB).
        constructor();
        /// Assert Lojban text as facts.
        assert-text: func(input: string) -> result<u32, nibli-error>;
        /// Query whether Lojban text is entailed.
        query-text: func(input: string) -> result<bool, nibli-error>;
        /// Query Lojban text with proof trace.
        query-text-with-proof: func(input: string) -> result<tuple<bool, proof-trace>, nibli-error>;
        /// Query Lojban text and return witness bindings for existential variables.
        query-find-text: func(input: string) -> result<list<list<witness-binding>>, nibli-error>;
        /// Debug: compile text to logic s-expression without asserting.
        compile-debug: func(input: string) -> result<string, nibli-error>;
        /// Reset the session's KB to fresh state.
        reset-kb: func() -> result<_, nibli-error>;
        /// Register a predicate name for external computation dispatch.
        register-compute-predicate: func(name: string);
        /// Assert a ground fact directly into the KB (bypasses Lojban parsing).
        assert-fact: func(relation: string, args: list<logical-term>) -> result<_, nibli-error>;
    }
}

world engine-pipeline {
    import parser;
    import semantics;
    import reasoning;
    import compute-backend;
    export engine;
}

