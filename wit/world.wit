package lojban:nesy@0.1.0;

interface ast-types {
    type selbri-id = u32;
    type sumti-id = u32;

    enum place-tag { fa, fe, fi, fo, fu }
    enum conversion { se, te, ve, xe }
    enum connective { je, ja, jo, ju }
    enum gadri { lo, le, la, ro-lo, ro-le }
    enum rel-clause-kind { poi, noi }

    record rel-clause {
        kind: rel-clause-kind,
        body-sentence: u32,
    }

    variant sumti {
        pro-sumti(string),
        description(tuple<gadri, selbri-id>),
        name(string),
        quoted-literal(string),
        unspecified,
        tagged(tuple<place-tag, sumti-id>),
        restricted(tuple<sumti-id, rel-clause>),
    }

    variant selbri {
        root(string),
        compound(list<string>),
        tanru(tuple<selbri-id, selbri-id>),
        converted(tuple<conversion, selbri-id>),
        negated(selbri-id),
        grouped(selbri-id),
        with-args(tuple<selbri-id, list<sumti-id>>),
        connected(tuple<selbri-id, connective, selbri-id>),
        /// nu abstraction: inner bridi lives in sentences[u32].
        /// Arity is 1 (x1 = event/proposition entity).
        abstraction(u32),
    }

    record bridi {
        relation: selbri-id,
        head-terms: list<sumti-id>,
        tail-terms: list<sumti-id>,
        negated: bool,
    }

    record ast-buffer {
        selbris: list<selbri>,
        sumtis: list<sumti>,
        sentences: list<bridi>,
        /// Indices into `sentences` for top-level sentences only.
        /// Rel clause bodies live in `sentences` but are NOT roots.
        roots: list<u32>,
    }

    // --- Logic Types ---
    variant logical-term {
        variable(string),
        constant(string),
        description(string),
        unspecified,
    }

    variant logic-node {
        predicate(tuple<string, list<logical-term>>),
        and-node(tuple<u32, u32>),
        or-node(tuple<u32, u32>),
        not-node(u32),
        exists-node(tuple<string, u32>),
        for-all-node(tuple<string, u32>),
    }

    record logic-buffer {
        nodes: list<logic-node>,
        roots: list<u32>,
    }
}

interface parser {
    use ast-types.{ast-buffer};
    parse-text: func(input: string) -> result<ast-buffer, string>;
}

interface semantics {
    use ast-types.{ast-buffer, logic-buffer};
    compile-buffer: func(ast: ast-buffer) -> result<logic-buffer, string>;
}

interface reasoning {
    use ast-types.{logic-buffer};
    assert-fact: func(logic: logic-buffer) -> result<_, string>;
    query-entailment: func(logic: logic-buffer) -> result<bool, string>;
}

// --- Component Worlds ---
world parser-component { export parser; }
world semantics-component { export semantics; }
world reasoning-component { export reasoning; }

world engine-pipeline {
    import parser;
    import semantics;
    import reasoning;

    /// Assert Lojban text as facts into the knowledge base.
    /// Returns the number of root facts inserted.
    export assert-text: func(input: string) -> result<u32, string>;

    /// Query whether Lojban text is entailed by the knowledge base.
    export query-text: func(input: string) -> result<bool, string>;

    /// Debug: compile text to logic s-expression without asserting.
    export compile-debug: func(input: string) -> result<string, string>;
}
