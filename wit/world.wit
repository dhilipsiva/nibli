package lojban:nesy@0.1.0;

interface ast-types {
    type selbri-id = u32;
    type sumti-id = u32;

    enum place-tag { fa, fe, fi, fo, fu }
    enum conversion { se, te, ve, xe }
    enum connective { je, ja, jo, ju }
    enum gadri { lo, le, la, ro-lo, ro-le }
    enum abstraction-kind { nu, duhu, ka, ni, siho }
    enum rel-clause-kind { poi, noi }

    record rel-clause {
        kind: rel-clause-kind,
        body-sentence: u32,
    }

    variant sumti {
        pro-sumti(string),
        description(tuple<gadri, selbri-id>),
        name(string),
        quoted-literal(string),
        unspecified,
        tagged(tuple<place-tag, sumti-id>),
        restricted(tuple<sumti-id, rel-clause>),
        number(f64),
        /// Sumti connective: left .e/.a/.o/.u [nai] right
        /// Fields: (left-sumti-id, connective, right-negated, right-sumti-id)
        connected(tuple<sumti-id, connective, bool, sumti-id>),
    }

    variant selbri {
        root(string),
        compound(list<string>),
        tanru(tuple<selbri-id, selbri-id>),
        converted(tuple<conversion, selbri-id>),
        negated(selbri-id),
        grouped(selbri-id),
        with-args(tuple<selbri-id, list<sumti-id>>),
        connected(tuple<selbri-id, connective, selbri-id>),
        /// Abstraction: inner bridi lives in sentences[u32].
        /// Arity is 1 (x1 = reified entity: event/proposition/property/quantity/concept).
        abstraction(tuple<abstraction-kind, u32>),
    }

    enum tense { pu, ca, ba }

    record bridi {
        relation: selbri-id,
        head-terms: list<sumti-id>,
        tail-terms: list<sumti-id>,
        negated: bool,
        tense: option<tense>,
    }

    enum sentence-connective { ganai-gi, ge-gi, ga-gi }

    variant sentence {
        simple(bridi),
        connected(tuple<sentence-connective, u32, u32>), // Pointers to other sentences
    }

    // Update ast-buffer to hold the new `sentence` variant:
    record ast-buffer {
        selbris: list<selbri>,
        sumtis: list<sumti>,
        sentences: list<sentence>, // <-- CHANGED from bridi to sentence
        roots: list<u32>,
    }


    // --- Logic Types ---
    variant logical-term {
        variable(string),
        constant(string),
        description(string),
        unspecified,
        number(f64),
    }

    variant logic-node {
        predicate(tuple<string, list<logical-term>>),
        and-node(tuple<u32, u32>),
        or-node(tuple<u32, u32>),
        not-node(u32),
        exists-node(tuple<string, u32>),
        for-all-node(tuple<string, u32>),
        past-node(u32),
        present-node(u32),
        future-node(u32),
    }

    record logic-buffer {
        nodes: list<logic-node>,
        roots: list<u32>,
    }
}

interface parser {
    use ast-types.{ast-buffer};
    parse-text: func(input: string) -> result<ast-buffer, string>;
}

interface semantics {
    use ast-types.{ast-buffer, logic-buffer};
    compile-buffer: func(ast: ast-buffer) -> result<logic-buffer, string>;
}

interface reasoning {
    use ast-types.{logic-buffer};
    assert-fact: func(logic: logic-buffer) -> result<_, string>;
    query-entailment: func(logic: logic-buffer) -> result<bool, string>;
    /// Clear the knowledge base, Skolem counter, entity registry,
    /// and universal templates. Returns to a fresh-boot state.
    reset-state: func() -> result<_, string>;
}

// --- Component Worlds ---
world parser-component { export parser; }
world semantics-component { export semantics; }
world reasoning-component { export reasoning; }

world engine-pipeline {
    import parser;
    import semantics;
    import reasoning;

    /// Assert Lojban text as facts into the knowledge base.
    /// Returns the number of root facts inserted.
    export assert-text: func(input: string) -> result<u32, string>;

    /// Query whether Lojban text is entailed by the knowledge base.
    export query-text: func(input: string) -> result<bool, string>;

    /// Debug: compile text to logic s-expression without asserting.
    export compile-debug: func(input: string) -> result<string, string>;

    /// Clear the entire knowledge base and reset to fresh state.
    export reset-kb: func() -> result<_, string>;
}

