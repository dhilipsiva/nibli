package lojban:nesy@0.1.0;

interface ast-types {
    type selbri-id = u32;
    type sumti-id = u32;

    enum place-tag { fa, fe, fi, fo, fu }
    enum bai-tag { ria, nii, mui, kiu, pio, bai }
    variant modal-tag {
        fixed(bai-tag),
        fio(selbri-id),
    }
    enum conversion { se, te, ve, xe }
    enum connective { je, ja, jo, ju }
    enum gadri { lo, le, la, ro-lo, ro-le }
    enum abstraction-kind { nu, duhu, ka, ni, siho }
    enum rel-clause-kind { poi, noi, voi }

    record rel-clause {
        kind: rel-clause-kind,
        body-sentence: u32,
    }

    variant sumti {
        pro-sumti(string),
        description(tuple<gadri, selbri-id>),
        name(string),
        quoted-literal(string),
        unspecified,
        tagged(tuple<place-tag, sumti-id>),
        modal-tagged(tuple<modal-tag, sumti-id>),
        restricted(tuple<sumti-id, rel-clause>),
        number(f64),
        /// Sumti connective: left .e/.a/.o/.u [nai] right
        /// Fields: (left-sumti-id, connective, right-negated, right-sumti-id)
        connected(tuple<sumti-id, connective, bool, sumti-id>),
        /// Numeric quantifier + description: PA lo/le selbri [ku]
        /// Fields: (count, gadri, selbri-id)
        quantified-description(tuple<u32, gadri, selbri-id>),
    }

    variant selbri {
        root(string),
        compound(list<string>),
        tanru(tuple<selbri-id, selbri-id>),
        converted(tuple<conversion, selbri-id>),
        negated(selbri-id),
        grouped(selbri-id),
        with-args(tuple<selbri-id, list<sumti-id>>),
        connected(tuple<selbri-id, connective, selbri-id>),
        /// Abstraction: inner bridi lives in sentences[u32].
        /// Arity is 1 (x1 = reified entity: event/proposition/property/quantity/concept).
        abstraction(tuple<abstraction-kind, u32>),
    }

    enum tense { pu, ca, ba }

    enum attitudinal { ei, ehe }

    record bridi {
        relation: selbri-id,
        head-terms: list<sumti-id>,
        tail-terms: list<sumti-id>,
        negated: bool,
        tense: option<tense>,
        attitudinal: option<attitudinal>,
    }

    variant sentence-connective {
        ganai-gi,
        ge-gi,
        ga-gi,
        /// Afterthought: .i [na] (je|ja|jo|ju) [nai]
        /// Fields: (left-negated, connective, right-negated)
        afterthought(tuple<bool, connective, bool>),
    }

    variant sentence {
        simple(bridi),
        connected(tuple<sentence-connective, u32, u32>), // Pointers to other sentences
    }

    record ast-buffer {
        selbris: list<selbri>,
        sumtis: list<sumti>,
        sentences: list<sentence>,
        roots: list<u32>,
    }
}

interface logic-types {
    variant logical-term {
        variable(string),
        constant(string),
        description(string),
        unspecified,
        number(f64),
    }

    variant logic-node {
        predicate(tuple<string, list<logical-term>>),
        /// A predicate dispatched to an external compute backend for evaluation.
        compute-node(tuple<string, list<logical-term>>),
        and-node(tuple<u32, u32>),
        or-node(tuple<u32, u32>),
        not-node(u32),
        exists-node(tuple<string, u32>),
        for-all-node(tuple<string, u32>),
        past-node(u32),
        present-node(u32),
        future-node(u32),
        obligatory-node(u32),
        permitted-node(u32),
        /// Exactly N entities satisfy the body: Count(variable-name, count, body-node-id)
        count-node(tuple<string, u32, u32>),
    }

    record logic-buffer {
        nodes: list<logic-node>,
        roots: list<u32>,
    }
}

interface parser {
    use ast-types.{ast-buffer};
    parse-text: func(input: string) -> result<ast-buffer, string>;
}

interface semantics {
    use ast-types.{ast-buffer};
    use logic-types.{logic-buffer};
    compile-buffer: func(ast: ast-buffer) -> result<logic-buffer, string>;
}

interface compute-backend {
    use logic-types.{logical-term};
    /// Evaluate whether a computed predicate holds for fully-ground arguments.
    evaluate: func(relation: string, args: list<logical-term>) -> result<bool, string>;
}

interface reasoning {
    use logic-types.{logic-buffer};

    resource knowledge-base {
        /// Create a fresh KB with FOL schema loaded.
        constructor();
        /// Assert FOL facts into this KB.
        assert-fact: func(logic: logic-buffer) -> result<_, string>;
        /// Query whether FOL formula is entailed by this KB.
        query-entailment: func(logic: logic-buffer) -> result<bool, string>;
        /// Reset this KB to fresh state (clear all facts, Skolems, rules).
        reset: func() -> result<_, string>;
    }
}

// --- Component Worlds ---
world parser-component { export parser; }
world semantics-component { export semantics; }
world reasoning-component {
    import compute-backend;
    export reasoning;
}

interface engine {
    use logic-types.{logical-term};

    resource session {
        /// Create a new session (internally creates a fresh KB).
        constructor();
        /// Assert Lojban text as facts.
        assert-text: func(input: string) -> result<u32, string>;
        /// Query whether Lojban text is entailed.
        query-text: func(input: string) -> result<bool, string>;
        /// Debug: compile text to logic s-expression without asserting.
        compile-debug: func(input: string) -> result<string, string>;
        /// Reset the session's KB to fresh state.
        reset-kb: func() -> result<_, string>;
        /// Register a predicate name for external computation dispatch.
        register-compute-predicate: func(name: string);
        /// Assert a ground fact directly into the KB (bypasses Lojban parsing).
        assert-fact: func(relation: string, args: list<logical-term>) -> result<_, string>;
    }
}

world engine-pipeline {
    import parser;
    import semantics;
    import reasoning;
    import compute-backend;
    export engine;
}

