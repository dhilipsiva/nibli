# Nibli

A Zero-Hallucination Symbolic Reasoning Engine.

Nibli is a deterministic theorem prover compiled to WebAssembly (WASI P2). It compiles Lojban natural language syntax into First-Order Logic and performs inference via egglog e-graph equality saturation. Every conclusion is formally derived — no hallucination, no approximation.

## Environment

- **OS:** Ubuntu on WSL2 (accessed from Windows via `\\wsl.localhost\Ubuntu\...`)
- **Dev shell:** Nix flake — all tools (rustc, cargo-component, wac, just, wasmtime) come from `flake.nix`
- **Enter dev shell:** `nix develop --extra-experimental-features nix-command --extra-experimental-features flakes`
- **Run commands from Windows side:** `wsl -d Ubuntu -e bash -lc "cd ~/projects/dhilipsiva/lojban_nesy_engine && nix ... develop --command bash -c '<CMD>'"`
- **Set `CARGO_INCREMENTAL=0`** if running cargo from Windows side (filesystem lock issues)

## Build & Test

All commands must run inside the Nix dev shell. Use `just` as the primary task runner (see `Justfile`):

| Command | What it does |
|---------|-------------|
| `just run` | Full pipeline: clean WASM -> build components -> fuse with wac -> launch REPL |
| `just test` | Run all unit tests (`cargo test --lib -- --nocapture --test-threads=1`) |
| `just test-parser` | Run parser tests only |
| `just test-backend` | Run Python backend tests |
| `just build-wasm` | Build WASM components + fuse with wac |
| `just build-runner` | Build native Wasmtime host runner |
| `just backend` | Start the Python reference compute backend (port 5555) |
| `just run-with-backend` | Build + run with `NIBLI_COMPUTE_ADDR=127.0.0.1:5555` |
| `just clean` | `cargo clean` |

**Important:**
- Always use `cargo test --lib` (NOT `cargo test`) — cdylib linker chokes on WIT export symbols containing `@`
- **Regenerate WIT bindings:** `cargo component build` (bindings appear in each crate's `src/bindings.rs`)
  - Note: full build fails on `io-extras` crate (`#![feature]` on stable). Bindings still generate successfully before the failure.
- **REPL uses reedline** — does not work with piped stdin
- Reasoning tests require `--test-threads=1` (shared global state: EGRAPH, KNOWN_ENTITIES). The Justfile handles this.

## Compute Backend

The runner acts as a TCP client to an external compute backend server via JSON Lines protocol.

- **Env var:** `NIBLI_COMPUTE_ADDR=host:port` — configures the backend address at startup
- **REPL command:** `:backend [host:port]` — show or change backend address at runtime
- **Protocol:** One JSON object per line. Request: `{"relation":"tenfa","args":[{"type":"number","value":8.0},...]}`. Response: `{"result":true}` or `{"error":"..."}`.
- **Fallback:** Built-in arithmetic (pilji/sumji/dilcu) always handled locally. Unknown predicates forward to external backend. If no backend configured, returns error.
- **Lazy connection:** TCP connects on first external dispatch, auto-reconnects on failure.
- **Reference server:** `python/nibli_backend.py` — handles pilji, sumji, dilcu, tenfa (exponent), dugri (log). Extend via `HANDLERS` dict.

## Architecture

5 WASM component crates + 1 native host:

| Crate | Role | Key files |
|-------|------|-----------|
| `parser` | Lojban text -> AST -> flat WIT buffer | `grammar.rs`, `ast.rs`, `lib.rs` (flattener), `lexer.rs` |
| `semantics` | Flat AST buffer -> FOL logic IR -> flat WIT logic buffer | `semantic.rs`, `ir.rs`, `lib.rs` (flattener) |
| `reasoning` | FOL logic buffer -> egglog e-graph assert/query | `lib.rs` (single file, all logic) |
| `orchestrator` | Glue: chains parser -> semantics -> reasoning | `lib.rs` |
| `runner` | Native Wasmtime host, REPL, external compute backend TCP client | `main.rs` |
| `python/` | Reference compute backend server (TCP + JSON Lines) | `nibli_backend.py` |

- **WIT interfaces:** `wit/world.wit` defines `ast-types` (parser output), `logic-types` (FOL IR), `parser`, `semantics`, `reasoning`, `compute-backend`, `engine`. `cargo component build` regenerates `src/bindings.rs` in each crate.
- **Cross-component data:** Flat index-based arrays (`AstBuffer`, `LogicBuffer`) with `u32` indices — no pointers across WASM boundaries.

## Code Conventions

- Parser tests use `as_bridi(&r.sentences[0])` helper to unwrap `Sentence::Simple`
- Grammar tests use `parse_ok()` / `parse_err()` + token constructors `cmavo()`, `gismu()`
- Semantics tests use `compile_one(selbris, sumtis, bridi)` helper returning `(LogicalForm, SemanticCompiler)`
- `resolve(&compiler, &spur)` helper to get string from interner in tests
- Connective enums (Je/Ja/Jo/Ju) are shared between selbri and sumti connectives
- BAI tags map to underlying gismu: ri'a->rinka, ni'i->nibli, mu'i->mukti, ki'u->krinu, pi'o->pilno, ba'i->basti

## Codebase Exclusions

When analyzing or searching the codebase:
- **Exclude `docs/` folder** — generated/reference documentation, not source
- **Exclude `**/bindings.rs`** — auto-generated by `cargo component build`, not hand-written

## Known Issues

- `cargo component build` fails on `io-extras` crate — pre-existing, unrelated to our changes. Bindings generate before the failure.

## Roadmap

See `todo.md` for the full phased roadmap (Phases 1-5), dependency graph, and technical debt tracker.

## Pre-commit Checklist

Before every commit, always:
1. Update `CLAUDE.md` — bump Current Status if a roadmap phase was completed
2. Update `todo.md` — remove completed tasks
3. Update `README.md` — if Lojban coverage or reasoning capabilities changed
4. Then commit all code + doc changes together

## Current Status

Completed through all Tier 1 items + full Tier 2 + full Tier 3 + full Tier 4 (production reasoning features: conjunction introduction, fuel limits, error variants, WASI sandboxing, clone-free connectives, arena allocator) + C2 (non-monotonic reasoning / belief revision) + C3 (temporal reasoning in e-graph) + C4 (event semantics — Neo-Davidsonian).

**Implemented features:**
- Lexer + recursive-descent parser (gismu, cmavo, cmevla, lujvo)
- Gadri descriptions (lo/le/la), universal (ro lo/ro le), numeric quantifiers (PA lo/le, su'o lo)
- Place tags (fa/fe/fi/fo/fu), BAI modal tags (ri'a, ni'i, mu'i, ki'u, pi'o, ba'i), fi'o...fe'u
- Selbri: root, tanru (Neo-Davidsonian event decomposition — shared event variable resolves intersective fallacy), conversion (se/te/ve/xe), negation (na), grouping (ke...ke'e), compounds (zei), be...bei...be'o
- Relative clauses (poi/noi/voi) with ke'a, implicit variable injection (ambiguous cases with nested descriptions rejected as error — requires explicit ke'a), clause stacking
- Sumti connectives (.e/.a/.o/.u + nai), selbri connectives (je/ja/jo/ju)
- Sentence connectives (forethought: ge...gi, ga...gi, ganai...gi; afterthought: .i je/ja/jo/ju with na/nai)
- Abstractions (nu, du'u, ka with ce'u, ni, si'o)
- Tense (pu/ca/ba), deontic attitudinals (ei/e'e)
- Quoted literals (lu...li'u), number sumti (li + PA)
- Skolemization (independent + dependent under ∀ via SkolemFn)
- All universals compile to native egglog rules with O(K) hash-join matching + xorlo presupposition Skolems (restrictor domain guaranteed non-empty)
- SkolemFn constructor for dependent Skolems (∀x. P(x) → ∃y. R(x,y))
- egglog e-graph reasoning with structural rewrites + inference rules
- Count quantifier (exactly N) for numeric descriptions
- da/de/di existential quantifier closure (bare logic variables now properly wrapped in ∃)
- Host-managed WIT resources: `resource knowledge-base` (reasoning) + `resource session` (engine interface)
- KnowledgeBase uses `RefCell` (not `Mutex`) — single-threaded WASI, no global state
- Numerical comparison predicates: zmadu (>), mleca (<), dunli (==) evaluated at query time on Num terms
- Computation dispatch WIT protocol: `compute-backend` interface, `ComputeNode` IR variant, predicate registry in orchestrator
- Built-in arithmetic evaluation: pilji (multiply), sumji (add), dilcu (divide) with query-time dispatch fallback chain
- Host-provided compute backend with wasmtime linker integration
- Generic external compute backend: TCP + JSON Lines client in runner, lazy connect, auto-reconnect
- Python reference backend server: pilji, sumji, dilcu, tenfa (exponentiation), dugri (logarithm)
- Compute result auto-ingestion: successful compute dispatch results automatically asserted into egglog KB as ground predicates
- Direct fact assertion: `assert-fact` WIT method on session resource bypasses Lojban parsing for trusted programmatic injection
- REPL `:assert` command: `:assert <relation> <arg1> <arg2> ...` for direct fact injection (numbers auto-detected, else constant)
- Deontic predicates: bilga (obligation), curmi (permission), nitcu (necessity) — standard gismu, work through full pipeline
- Bidirectional material conditional rewrite enables modus ponens/tollens on sentence connectives (ganai...gi)
- Deontic attitudinals: ei (obligation/should), e'e (competence/permission/may) — sentence-level modifiers, transparent wrapper nodes in reasoning
- Lujvo morphological recognition: Logos regex `[a-z']{5}[a-z']*[aeiou]` captures 6+ char brivla; longest-match prevents cmavo prefix theft; PHF dictionary handles arity lookup
- Observative sentences & go'i pro-bridi: parser accepts sentences without explicit selbri (inserts implicit `go'i`), orchestrator resolves go'i via `SelbriSnapshot` deep-clone preserving full selbri structure (negation, conversion, tanru, be/bei args, abstractions) across calls
- Metalinguistic `sa` construct-class erasure: proper selma'o classification (28 classes) with backward-walk to matching grammatical class; graceful fallback to single-word erase for unclassified cmavo
- Existential witness extraction: `query-find` WIT method + `find_witnesses` reasoning function returns all satisfying binding sets for existential variables; `ma` question pro-sumti compiles to existential variable (like da/de/di); REPL `??` prefix for find queries
- Proof trace generation: `check_formula_holds_traced` builds proof tree as it recurses, recording which rule/axiom was applied at each step (15 proof rule variants); `query-entailment-with-proof` / `query-text-with-proof` WIT methods; REPL `?!` prefix for traced queries with indented tree output
- Multi-hop derivation provenance: backward-chaining reconstruction traces derived facts through universal rule chains (e.g., `gerku(alis) → danlu(alis) → xanlu(alis)`); `UniversalRuleRecord` captures rule templates at compilation time; s-expression pattern matching unifies conclusion templates against queried facts; `Asserted(sexp)` leaf nodes distinguish ground truths from `Derived(label, sexp)` nodes with recursive children; depth-limited (10) with graceful fallback to opaque `PredicateCheck`; zero overhead on egglog saturation hot path
- Parser error recovery: per-sentence recovery (skip to next `.i` on parse failure, continue parsing remaining sentences); `ParseResult` carries both partial results and errors; exact line:column reporting via pointer arithmetic on token `&str` slices; WIT `parse-error` and `parse-result` types; orchestrator surfaces parse warnings
- WASM fuel limits: Wasmtime fuel-based execution limits prevent unbounded computation; per-command refuel in REPL; configurable via `NIBLI_FUEL` env var or `:fuel` REPL command; friendly `[Limit]` message on fuel exhaustion
- WASM memory limits: Wasmtime `StoreLimits` caps WASM linear memory growth; configurable via `NIBLI_MEMORY_MB` env var (default 512 MB) or `:memory` REPL command; prevents adversarial e-graph growth from crashing host
- Guarded conjunction introduction: egglog rule derives `And(A, B)` when both A, B are atomic `Pred` forms sharing an `InDomain` entity; `PredHasEntity` helper relation extracts entities from argument positions x1-x3; prevents combinatorial explosion by excluding `(Zoe)` and non-entity terms
- WIT typed error variants: shared `nibli-error` variant (syntax/semantic/reasoning/backend) replaces `Result<_, String>` across all 14 WIT functions; `syntax-detail` record carries line:column; orchestrator propagates via `?`; runner pattern-matches for structured `[Syntax Error]`/`[Semantic Error]`/`[Reasoning Error]`/`[Backend Error]` REPL output
- WASI capability sandboxing: replaced `inherit_stdio()` with `inherit_stdout().inherit_stderr()` — WASM components get only stdout/stderr (for diagnostic prints), no stdin, no filesystem, no network, no env vars
- Clone-free Jo/Ju connectives: added `Biconditional` and `Xor` variants to `LogicalForm` IR — each operand stored once, expansion to And/Or/Not happens during flattening where operands are u32 indices (zero-cost copy); eliminated 6 deep `.clone()` calls across 3 compilation sites
- Arena-allocated parser AST: bumpalo `Bump` arena replaces all `Box<T>` with `&'arena T` in AST types; 24 heap allocations per parse batched into contiguous arena chunks; arena created per `parse_text()` call, freed in one shot after flattening; enables memory reuse via `Bump::reset()` for batch corpus processing
- Non-monotonic reasoning / belief revision: fact registry with per-assertion FactId (u64), FactRecord stores cloned LogicBuffer + label + retracted flag; retraction marks fact withdrawn then rebuilds egraph from surviving base facts (sound because all derived facts recomputed); `retract-fact` and `list-facts` WIT methods on both `knowledge-base` and `session` resources; REPL `:retract <id>` and `:facts` commands; idempotent retraction; `rebuilding` flag suppresses diagnostic prints during replay
- Temporal reasoning in e-graph: `Past`/`Present`/`Future` constructors in egglog `Formula` datatype; tense wrappers preserved end-to-end (assertion, query, rule compilation, proof tracing, witness extraction); tense conjunction elimination rules; temporal entity extraction for guarded conjunction introduction; temporal lifting of universal rules (timeless rules automatically fire on tensed premises to derive tensed conclusions); tense-aware backward-chaining provenance; strict tense discrimination (Past ≠ Future ≠ bare)

- Neo-Davidsonian event semantics: every predication decomposes into event type predicate + Lojban-native role predicates (`klama(e) ∧ klama_x1(e, alis) ∧ klama_x2(e, paris)`); fresh `_ev0`, `_ev1` event variables separate from entity `_v0` variables; tanru share event variable between modifier and head (`sutra gerku` → `∃e. gerku(e) ∧ gerku_x1(e, x) ∧ sutra_x1(e, x)`), resolving the intersective fallacy; `event_decompose()` method on SemanticCompiler produces `∃e. type(e) ∧ role_x1(e, a1) ∧ ...`; all role predicates emitted (including Unspecified/zo'e) for inject_variable compatibility; `inject_variable` and `count_unspecified_predicates` updated to only target `_x1` role predicates; recursive selbri (Converted/Negated/Grouped/Connected/WithArgs) get event decomposition automatically via delegation; abstraction inner forms (`nu`/`du'u`/`ka`/`ni`/`si'o`) event-decomposed naturally through `compile_sentence`

**Next up:** C5 (Description term opacity — `le` vs `lo`)
