# Nibli

A Zero-Hallucination Symbolic Reasoning Engine.

Nibli is a deterministic theorem prover compiled to WebAssembly (WASI P2). It compiles Lojban natural language syntax into First-Order Logic and performs inference via egglog e-graph equality saturation. Every conclusion is formally derived — no hallucination, no approximation.

## Environment

- **OS:** Ubuntu on WSL2 (accessed from Windows via `\\wsl.localhost\Ubuntu\...`)
- **Dev shell:** Nix flake — all tools (rustc, cargo-component, wac, just, wasmtime) come from `flake.nix`
- **Enter dev shell:** `nix develop --extra-experimental-features nix-command --extra-experimental-features flakes`
- **Run commands from Windows side:** `wsl -d Ubuntu -e bash -lc "cd ~/projects/dhilipsiva/lojban_nesy_engine && nix ... develop --command bash -c '<CMD>'"`
- **Set `CARGO_INCREMENTAL=0`** if running cargo from Windows side (filesystem lock issues)

## Build & Test

All commands must run inside the Nix dev shell. Use `just` as the primary task runner (see `Justfile`):

| Command | What it does |
|---------|-------------|
| `just run` | Full pipeline: clean WASM -> build components -> fuse with wac -> launch REPL |
| `just test` | Run all unit tests (`cargo test --lib -- --nocapture`) |
| `just test-parser` | Run parser tests only |
| `just build-wasm` | Build WASM components + fuse with wac |
| `just build-runner` | Build native Wasmtime host runner |
| `just clean` | `cargo clean` |

**Important:**
- Always use `cargo test --lib` (NOT `cargo test`) — cdylib linker chokes on WIT export symbols containing `@`
- **Regenerate WIT bindings:** `cargo component build` (bindings appear in each crate's `src/bindings.rs`)
  - Note: full build fails on `io-extras` crate (`#![feature]` on stable). Bindings still generate successfully before the failure.
- **REPL uses reedline** — does not work with piped stdin

## Architecture

5 WASM component crates + 1 native host:

| Crate | Role | Key files |
|-------|------|-----------|
| `parser` | Lojban text -> AST -> flat WIT buffer | `grammar.rs`, `ast.rs`, `lib.rs` (flattener), `lexer.rs` |
| `semantics` | Flat AST buffer -> FOL logic IR -> flat WIT logic buffer | `semantic.rs`, `ir.rs`, `lib.rs` (flattener) |
| `reasoning` | FOL logic buffer -> egglog e-graph assert/query | `lib.rs` (single file, all logic) |
| `orchestrator` | Glue: chains parser -> semantics -> reasoning | `lib.rs` |
| `runner` | Native Wasmtime host, REPL, loads fused WASM | `main.rs` |

- **WIT interface:** `wit/world.wit` defines all shared types. `cargo component build` regenerates `src/bindings.rs` in each crate.
- **Cross-component data:** Flat index-based arrays (`AstBuffer`, `LogicBuffer`) with `u32` indices — no pointers across WASM boundaries.

## Code Conventions

- Parser tests use `as_bridi(&r.sentences[0])` helper to unwrap `Sentence::Simple`
- Grammar tests use `parse_ok()` / `parse_err()` + token constructors `cmavo()`, `gismu()`
- Semantics tests use `compile_one(selbris, sumtis, bridi)` helper returning `(LogicalForm, SemanticCompiler)`
- `resolve(&compiler, &spur)` helper to get string from interner in tests
- Connective enums (Je/Ja/Jo/Ju) are shared between selbri and sumti connectives
- BAI tags map to underlying gismu: ri'a->rinka, ni'i->nibli, mu'i->mukti, ki'u->krinu, pi'o->pilno, ba'i->basti

## Codebase Exclusions

When analyzing or searching the codebase:
- **Exclude `docs/` folder** — generated/reference documentation, not source
- **Exclude `**/bindings.rs`** — auto-generated by `cargo component build`, not hand-written

## Known Issues

- `test_kea_as_head_term` and `test_kea_in_relative_clause` fail with "observative sentences not yet supported" (pre-existing)
- `push_bridi` in `parser/src/lib.rs` is dead code (unused warning)
- `cargo component build` fails on `io-extras` crate — pre-existing, unrelated to our changes. Bindings generate before the failure.
- Existential introduction gap: `ro lo gerku cu danlu` then `? lo gerku cu danlu` returns FALSE because engine lacks ∀x.P(x) ⊢ ∃x.P(x) bridging when domain is non-empty (see `todo.md` bottom for full analysis)

## Roadmap

See `todo.md` for the full phased roadmap (Phases 1-5), dependency graph, and technical debt tracker.

## Pre-commit Checklist

Before every commit, always:
1. Update `CLAUDE.md` — bump Current Status if a roadmap phase was completed
2. Update `todo.md` — remove completed tasks
3. Update `README.md` — if Lojban coverage or reasoning capabilities changed
4. Then commit all code + doc changes together

## Current Status

Completed through Tier 1.1 Phase A.

**Implemented features:**
- Lexer + recursive-descent parser (gismu, cmavo, cmevla, lujvo partial)
- Gadri descriptions (lo/le/la), universal (ro lo/ro le), numeric quantifiers (PA lo/le, su'o lo)
- Place tags (fa/fe/fi/fo/fu), BAI modal tags (ri'a, ni'i, mu'i, ki'u, pi'o, ba'i), fi'o...fe'u
- Selbri: root, tanru, conversion (se/te/ve/xe), negation (na), grouping (ke...ke'e), compounds (zei), be...bei...be'o
- Relative clauses (poi/noi/voi) with ke'a, implicit variable injection, clause stacking
- Sumti connectives (.e/.a/.o/.u + nai), selbri connectives (je/ja/jo/ju)
- Sentence connectives (forethought: ge...gi, ga...gi, ganai...gi; afterthought: .i je/ja/jo/ju with na/nai)
- Abstractions (nu, du'u, ka with ce'u, ni, si'o)
- Tense (pu/ca/ba)
- Quoted literals (lu...li'u), number sumti (li + PA)
- Skolemization (independent + dependent under ∀)
- Native egglog rules for simple universals (Phase A), Herbrand fallback for dependent-Skolem universals
- egglog e-graph reasoning with structural rewrites + inference rules
- Count quantifier (exactly N) for numeric descriptions
- da/de/di existential quantifier closure (bare logic variables now properly wrapped in ∃)

**Next up:** Tier 1.1 Phase B (SkolemFn for dependent Skolems) or Tier 1.2 (WASI state hoisting)
